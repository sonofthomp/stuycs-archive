<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
    <title>Notes | Computer Graphics</title>
    <meta name="generator" content="Jekyll v3.9.2" />
    <meta property="og:title" content="Notes" />
    <meta property="og:locale" content="en_US" />
    <meta
      name="description"
      content="Class website for Mr. Dyrland-Weaver’s Computer Graphics Sections"
    />
    <meta
      property="og:description"
      content="Class website for Mr. Dyrland-Weaver’s Computer Graphics Sections"
    />
    <link
      rel="canonical"
      href="http://moe.stuy.edu/~gthompson30/stuycsarchive/graphics/notes/"
    />
    <meta
      property="og:url"
      content="http://moe.stuy.edu/~gthompson30/stuycsarchive/graphics/notes/"
    />
    <meta property="og:site_name" content="Computer Graphics" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Notes" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "description": "Class website for Mr. Dyrland-Weaver’s Computer Graphics Sections",
        "headline": "Notes",
        "url": "http://moe.stuy.edu/~gthompson30/stuycsarchive/graphics/notes/"
      }
    </script>
    <!-- End Jekyll SEO tag -->
    <link rel="stylesheet" href="/stuycs-archive/graphics/assets/main.css" />
    <link
      type="application/atom+xml"
      rel="alternate"
      href="http://moe.stuy.edu/~gthompson30/stuycsarchive/graphics/feed.xml"
      title="Computer Graphics"
    />
    <!-- removing jquery and bootstrap assets
  <script   src="https://code.jquery.com/jquery-3.4.1.min.js"   integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="   crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="../assets/js/bootstrap.min.js"></script>
  -->

    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <link
      rel="stylesheet"
      href="/stuycs-archive/graphics/assets/css/site.css"
    />
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
  </head>
  <style>
    .container {
      display: flex;
    }
    .notes_nav {
      /*  position: fixed; */
      /*background-color: #5F5980;*/
      width: 25%;
    }
    .notes_nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      padding-top: 5em;
      margin-right: 5px;
      /*width: max-content;*/
    }
    .notes_nav ul li {
      border-bottom: 1px solid white;
    }
    .notes_content {
      border-left: 1px solid white;
      padding-left: 0.5em;
    }
    img {
      display: block;
      margin: auto;
    }
  </style>

  <body>
    <nav>
      <ul class="navbar">
        <li>
          <a href="../../">StuyCSArchive</a>
        </li>

        <li class="active">
          <a href="../">Graphics</a>
        </li>

        <li class="">
          <a href="../assignments">Assignments</a>
        </li>

        <li class="active">
          <a href="../notes">Notes</a>
        </li>

        <li class="">
          <a href="../resources">Resources</a>
        </li>
      </ul>
    </nav>
    <div class="container">
      <div class="notes_nav">
        <ul>
          <li><a href="#image-file-formats">00 Image Files</a></li>
          <li><a href="#bresenhams-line-algorithm">01 Lines!</a></li>
          <li><a href="#using-edge-lists">02 Edge Lists</a></li>
          <li><a href="#transformations">03 Transformations</a></li>
          <li><a href="#parametric-equations">04 Parametrics</a></li>
          <li><a href="#3d-shapes">05 3D Shapes</a></li>
          <li><a href="#using-polygons">06 Polygons</a></li>
          <li><a href="#backface-culling">07 Backface Culling</a></li>
          <li>
            <a href="#relative-coordinate-systems"
              >08 Relative Coordinate Systems</a
            >
          </li>
          <li><a href="#scanline-conversion">09 Scanline Conversion</a></li>
          <li><a href="#z-buffering">10 Z-Buffering</a></li>
          <li>
            <a href="#light-and-reflection-types">11 Light & Reflection</a>
          </li>
          <li><a href="#lighting-model">12 Lighting Model</a></li>
          <li><a href="#compiler-design">13 Compiler Design</a></li>
          <li>
            <a href="#using-flex-and-bison-to-create-mdl">14 Flex & Bison</a>
          </li>
        </ul>
      </div>

      <div class="notes_content">
        <header class="post-header">
          <h1 class="post-title">Notes</h1>
        </header>

        <h3 id="image-file-formats">Image File Formats</h3>
        <p><strong>Vector</strong></p>
        <ul>
          <li>
            Vector formats represent images as a series of drawing instructions.
          </li>
          <li>Infinitely scalable.</li>
          <li>Common file type: SVG (Scalable Vector Graphics).</li>
        </ul>

        <p><strong>Raster</strong></p>
        <ul>
          <li>
            Raster formats represent images as a grid of color values (pixels).
          </li>
        </ul>

        <h3 id="raster-file-types">Raster File Types</h3>
        <ul>
          <li>
            Uncompressed formats contain data for each pixel.
            <ul>
              <li>Common file types: BMP, TIFF, RAW</li>
            </ul>
          </li>
          <li>
            Compressed formats use a compression algorithm to minimize file
            size.
            <ul>
              <li>
                <em>Lossless</em> vs. <em>Lossy</em>
                <ul>
                  <li>
                    <em>Lossless</em> compression algorithms contain enough
                    information to exactly recreate the original image.
                  </li>
                  <li>
                    Common file types: PNG (Portable Network Graphics), GIF
                    (Graphics Interchange Format)
                  </li>
                </ul>
              </li>
              <li>
                <em>Lossy</em> compression algorithms do not retain all the
                details of the original image.
              </li>
              <li>Common file type: JPEG (Joint Photographic Experts Group)</li>
            </ul>
          </li>
        </ul>

        <h3 id="netpbm-file-formats">NetPBM File Formats</h3>

        <p>
          A family of uncompressed raster image file formats (<a
            href="https://en.wikipedia.org/wiki/Netpbm"
            >more info</a
          >).
        </p>

        <p>File Type for this class: PPM (Portable PixMap)</p>
        <ul>
          <li>
            Pixel data is represented by RGB triplets in either ASCII or binary.
          </li>
          <li>All whitespace is equivalent.</li>
          <li>
            example file:
            <div class="language-plaintext highlighter-rouge">
              <div class="highlight">
                <pre class="highlight"><code>P3
4 3
255
255 0 0  255 0 0  255 0 0  255 0 0
0 255 0  0 255 0  0 255 0  0 255 0
0 0 255  0 0 255  0 0 255  0 0 255
</code></pre>
              </div>
            </div>
          </li>
          <li>
            File Header
            <ul>
              <li>
                <code class="language-plaintext highlighter-rouge">P3</code>:
                Type of PPM, 3-btye RGB, in ASCII (<code
                  class="language-plaintext highlighter-rouge"
                  >P6</code
                >
                is RGB in binary)
              </li>
              <li>
                <code class="language-plaintext highlighter-rouge">4 3</code>:
                Width x Height, in pixels
              </li>
              <li>
                <code class="language-plaintext highlighter-rouge">255</code>:
                Maximum value per color (will scale to 255 if not 255)
              </li>
            </ul>
          </li>
        </ul>

        <h5 id="back-to-top"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="bresenhams-line-algorithm">Bresenhams Line Algorithm</h3>

        <p>
          The particular problem of drawing a line on a computer screen, is that
          the physical pixels, and the data structures we use to represent
          images in memory, are bound by integer coordinates. We cannot exactly
          represent a line that in reality has an infinite amount of non-integer
          points along it. The purpose of a line algorithm is to find the
          pixels, using integer coordinates, that <em>best approximate</em> what
          the line should look like.
        </p>

        <p>
          The basic concept of Bresenham’s Line Algorithm is to find potential
          pixels that we think would be good candidates for the line, test them,
          and then select the best one. To begin, we will start by restricting
          our line algorithm to only lines where \(0&lt;m&lt;1\), this will help
          narrow doent the possible pixels. Eventually, we can modify it to work
          for the other octants. We will also assume that our endpoints
          \((x_{0}, y_{0}), (x_{1}, y_{1})\) only have integer coordinates. With
          those restrictions in place, if we are drawing a line as starting at
          \((x_{0}, y_{0})\), we only have 2 candidate pixels, \(A: (x_{0}+1,
          y_{0})\) and \(B: (x_{0}+1, y_{0})\):
        </p>

        <p><img src="../assets/img/n01-grid.jpg" alt="n01_grid" /></p>

        <p>
          Furthermore, since we know the slope is less than 1 (and positive), we
          know that we can create our line by moving forward in x by 1 until we
          reach \(x_{1}\). If we assume there is a function \(f(x, y)\), that we
          can use to test our candidate points, we have all we need for an
          initial algorithm:
        </p>

        <div class="language-plaintext highlighter-rouge">
          <div class="highlight">
            <pre class="highlight"><code>x = x0, y = y0
while x &lt;= x1
  plot(x, y) //actually draw the pixel
  d0 = f(x+1, y)
  d1 = f(x+1, y+1)
  if d1 &lt; d0 //meaning d1 is close to the real line
    y++ //only incriment y when necessart
  x++ //we always incriment x
</code></pre>
          </div>
        </div>

        <p>
          This will work, but we can make it more efficient, and we have to
          acutally define \(f\). First off, instead of testing both possible
          points, we could test the midpoint, \((x+1, y+\dfrac{1}{2})\). The
          midpoint of the possible pixels is on the border between them, which
          leaves us with 3 possibilities:
        </p>
        <ol>
          <li>
            The midpoint is <em>above</em> the line. This means the line is
            mostly below the midpoint, and we should choose the lower pixel,
            \((x+1, y)\).
          </li>
          <li>
            The midpoint to <em>below</em> the line. This means the line is
            mostly above the midpoint, and we should choose the upper pixel,
            \((x+1, y+1)\).
          </li>
          <li>
            The midpoint is <em>on</em> the line. In this case, either pixel is
            a good match.
          </li>
        </ol>

        <p>
          With that information in hand, we turn towards \(f\), which ideally
          will tell us the relationship of the testing point to the actual line.
          Luky for us, this is exactly what we get if we use the acual equation
          of the line. If \(f(x, y)\) is the equation of the line then the ouput
          will be:
        </p>
        <ol>
          <li>A positive value if the midpoint is above the line.</li>
          <li>A negative value if the midpoint is below the line.</li>
          <li>\(0\) if the midpoint is on the line.</li>
        </ol>

        <p>This brings us to the next iteration of the algorithm:</p>

        <div class="language-plaintext highlighter-rouge">
          <div class="highlight">
            <pre class="highlight"><code>x = x0, y = y0
d = f(x+1, y+1/2)
while x &lt;= x1
  plot(x, y) //actually draw the pixel
  if d &lt; 0 //-d value means the m.p. is below the line
    y++ //only incriment y when necessart
  x++ //we always incriment x
  d = f(x, y)
</code></pre>
          </div>
        </div>

        <p>
          Let’s keep working on \(f\). We will use the standard form of a line:
          \(f(x, y) = Ax + By + C\). Where \(A = (y1-y0)\), \(B = -(x1-x0)\),
          and \(C = b(y1-y0)\) (here \(b\) is the y-intercept). The first time
          we run \(f\) is on \((x_{0}+1, y_{0}+\dfrac{1}{2})\):
        </p>

        \[\begin{aligned} f(x_{0}+1, y_{0}+\dfrac{1}{2}) = A(x_{0}+1) +
        B(y_{0}+\dfrac{1}{2}) + C \\ f(x_{0}+1, y_{0}+\dfrac{1}{2}) = Ax_{0} +
        By_{0} + C + A + \dfrac{1}{2}B \\ f(x_{0}+1, y_{0}+\dfrac{1}{2}) =
        f(x_{0}, y_{0}) + A + \dfrac{1}{2}B \\ f(x_{0}+1, y_{0}+\dfrac{1}{2}) =
        A + \dfrac{1}{2}B \end{aligned}\]

        <p>
          \((x_{0}, y_{0})\) is on the line so we know \(f(x_{0}, y_{0}) = 0\).
          This results in an intial calculation based on values that are
          straightforward to get given the endpoints of the line. This is not a
          huge benefit though, since we’re still calculating \(f\) repeatedly
          inside our loop. So let’s think about what’s happening inside the
          loop. Each time the loop runs, we add 1 to \(x\), and sometimes we add
          1 to \(y\). Look at what happens when we choose \((x+1, y+1)\).
        </p>

        \[\begin{aligned} f(x+1, y+1) = A(x+1) + B(y+1) + C \\ f(x+1, y+1) = Ax
        + By + C + A + B \\ f(x+1, y+1) = f(x, y) + A + B \end{aligned}\]

        <p>
          If \(d\) represents the previous value of \(f\), calculcated as \(f(x,
          y)\), then if we use \((x+1, y+1)\), the result is \(d + A + B\). In
          general, every time we add 1 to \(x\), we must add \(A\) to \(d\), and
          every time we add 1 to \(y\), we must add \(B\) to \(d\). This means
          we can remove \(f\) from our algorithm entirely, giving us (this
          version starts by multiplying \(A\) and \(B\) by 2 in order to keep
          all values as integers):
        </p>

        <div class="language-plaintext highlighter-rouge">
          <div class="highlight">
            <pre class="highlight"><code>x = x0, y = y0
A = 2(y1 - y0)
B = -2(x1 - x0)
d = A + 1/2B
while x &lt;= x1
  plot(x, y)
  if d &lt; 0
    y++
    d+= B
  x++
  d+= A
</code></pre>
          </div>
        </div>

        <p>
          Another way to think about this algorithm is to consider
          <code class="language-plaintext highlighter-rouge">d</code> as a
          variable that accumulates how off from the true line we have become.
          If we were always exactly on the line (this is the case for slopes 1,
          0 and undefined), we’d be adding
          <code class="language-plaintext highlighter-rouge">0</code> to
          <code class="language-plaintext highlighter-rouge">d</code> each loop
          iteration. Given that we are starting with positive slopes less than
          1, our loop is designed to always increase x, and occasionally, when
          <code class="language-plaintext highlighter-rouge">d</code> has
          accumulated too much error, we need to increase
          <code class="language-plaintext highlighter-rouge">y</code>.
          <code class="language-plaintext highlighter-rouge">A</code> is based
          off the change in
          <code class="language-plaintext highlighter-rouge">y</code>, which is
          always positive,
          <code class="language-plaintext highlighter-rouge">B</code> is the
          negation in the change in
          <code class="language-plaintext highlighter-rouge">x</code>, which is
          always negative. When
          <code class="language-plaintext highlighter-rouge">d</code> becomes
          negative overall, it means we’ve gone too far from the line, and need
          to make it positive by adding
          <code class="language-plaintext highlighter-rouge">A</code> and also
          increasing in
          <code class="language-plaintext highlighter-rouge">y</code>.
        </p>

        <p>
          Now we need to revisit our initail restriction, that \(0 &lt; m &lt;
          1\). In graphics, we often take the coordinate plan and break it up
          into 8 sections, called <em>octants</em>:
        </p>

        <p><img src="../assets/img/n01-octants.jpg" alt="n01_octants" /></p>

        <p>
          In order to have a fully functioning line algorithm, we need to handle
          any slope. Thankfully, we can ignore octants III - V, becuase those
          slopes correspond to lines in octants I, II, VII and VIII. To
          translate our octant 1 algorithm to another octant, we need to look at
          what has changed, and how that impacts the calculations.
        </p>

        <p>
          In octant II, \(1 &lt; m &lt; \infty\), or, the line goes up more
          often than it goes across. This means:
        </p>
        <ol>
          <li>
            Our loop should be based on y values:
            <code class="language-plaintext highlighter-rouge"
              >while y &lt;= y1</code
            >.
          </li>
          <li>
            Our loop should always run
            <code class="language-plaintext highlighter-rouge">y++</code> and
            <code class="language-plaintext highlighter-rouge">d+=B</code>, and
            only run
            <code class="language-plaintext highlighter-rouge">x++</code> and
            <code class="language-plaintext highlighter-rouge">d+=A</code>
            inside a conditional statment.
          </li>
          <li>
            The first midpoint is based off of \(f(x_{0}+\dfrac{1}{2},
            y_{0}+1)\):
            <code class="language-plaintext highlighter-rouge"
              >d = 1/2A + B</code
            >
          </li>
          <li>
            <code class="language-plaintext highlighter-rouge">A</code> is
            positive, and since we are always adding
            <code class="language-plaintext highlighter-rouge">A</code> to
            <code class="language-plaintext highlighter-rouge">d</code>, the
            trigger for increasing
            <code class="language-plaintext highlighter-rouge">x</code> should
            be
            <code class="language-plaintext highlighter-rouge">d &gt; 0</code>,
            so that the neagative value,
            <code class="language-plaintext highlighter-rouge">B</code> can
            correct the overly positive error.
          </li>
        </ol>

        <h5 id="back-to-top-1"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="using-edge-lists">Using Edge Lists</h3>
        <p>
          Until we start to render 3D shapes, all of our images will be
          generated by calling
          <code class="language-plaintext highlighter-rouge">draw_line</code>
          between pairs of points. To help organize, and later modify, our
          images better, we will store these points in an <em>edge list</em>,
          and only call
          <code class="language-plaintext highlighter-rouge">draw_line</code>
          (and thus modify our screen object) when we are ready to render the
          entire image.
        </p>
        <ul>
          <li>
            All shapes will be added as a series of edges to the main edge list.
          </li>
          <li>
            Any transformations (more on that later) will be applied to the main
            edge list.
          </li>
          <li>
            When we are ready to see/save an image, we will iterate over the
            edge list calling
            <code class="language-plaintext highlighter-rouge">draw_line</code>.
          </li>
        </ul>

        <p>
          There are a few options for maintaining edge lists. Consider the
          following image:
        </p>

        <p><img src="../assets/img/n00-image.png" alt="points" /></p>

        <ul>
          <li>
            The triangle portion could be represented by any of the following
            edge lists: \begin{bmatrix}P_{0} &amp; P_{1} &amp;
            P_{2}\end{bmatrix}
            <ul>
              <li>
                Here, we would generate the image by iterating through the edge
                list 1 point at a time, connecting each point with the next one,
                and include a final line back to the initial point.
              </li>
              <li>
                This works well if the entire image was a single closed object,
                but less so for open ended or disjoint objects.
                \begin{bmatrix}P_{0} &amp; P_{1} &amp; P_{2} &amp;
                P_{0}\end{bmatrix}
              </li>
              <li>
                This is very similar to the first, execpt there’s no implicit
                connection from the last point to the first.
              </li>
              <li>
                This means we <em>could</em> have open ended shapes, but
                disjoint shapes, like the diamond, would not be as simple, since
                in this option, by adding \(P_{3}\) we wouild get a line
                \(\overline{P_{0}P_{3}}\), which we don’t want.
                \begin{bmatrix}P_{0} &amp; P_{1} &amp; P_{1} &amp; P_{2} &amp;
                P_{2} &amp; P_{0}\end{bmatrix}
              </li>
              <li>
                In this version, we would generate the image by iterating over
                the list by pairs of points, drawing the lines between them.
              </li>
              <li>
                The advantage to this approach is that the list need not “know”
                anything about the image and what it contains. Every edge is
                explicitly defined.
              </li>
              <li>
                The downside is that there is a lot of duplication of points,
                but hey, memory’s cheap.
              </li>
            </ul>
          </li>
          <li>
            We will focus on the last implementation, the other two are viable,
            but require extra work to be able to draw any arbitrary image (such
            as a separate list containing # of edges per shape, or a “delimeter”
            point).
          </li>
        </ul>

        <p>
          It is important to remember that points are \((x, y, z)\) triples, so
          our edge lists would more accurately look like the following:
          \begin{bmatrix}x_{0} &amp; x_{1} &amp; x_{1} &amp; x_{2} &amp; \dots
          &amp; x_{n} \\ y_{0} &amp; y_{1} &amp; x_{1} &amp; y_{2} &amp; \dots
          &amp; y_{n} \\ z_{0} &amp; z_{1} &amp; z_{1} &amp; z_{2} &amp; \dots
          &amp; z_{n} \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; \dots &amp; 1
          \end{bmatrix}
        </p>
        <ul>
          <li>
            The extra row of 1s at the bottom is necessary for certain
            transformations that we will cover later.
          </li>
        </ul>

        <h5 id="back-to-top-2"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="graphics-matrix-math">Graphics Matrix Math</h3>

        <p>
          Now that we are arranging our image information as edge matrices, we
          should look into how we can leverage matrix math for graphics
          purposes. To start, we need only talk about two concepts,
          <em>matrix multiplication</em> and the
          <em>multiplicative identiy matrix</em>.
        </p>

        <p><strong>Matrix Multiplication</strong></p>
        <ul>
          <li>
            In order to mulply two matrices, \(AB\), the number of columns in
            \(A\) must equal the number of rows in \(B\). So if \(A\) is a
            \(4\times N\) matrix, then \(B\) must be \(n\times4\)
          </li>
          <li>
            Matrix multiplication is <em>not</em> commutative, so \(AB \neq
            BA\). This will be useful to us later on.
          </li>
          <li>
            To perform \(AB\), you match up each <em>row</em> of \(A\) with the
            coresponding <em>column</em> in \(B\), multiply each coresponding
            element, and add those products together to find each element in the
            product matrix. For a simple example, consider the following:
          </li>
        </ul>

        \[\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 4\end{bmatrix}
        \begin{bmatrix}a\\b\\c\\d \end{bmatrix} = \begin{bmatrix}1a + 2b + 3c +
        4d\end{bmatrix}\]

        <ul>
          <li>For a more complex example:</li>
        </ul>

        \[\begin{bmatrix}1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8
        &amp; 9\end{bmatrix} \begin{bmatrix}a &amp; b \\ c &amp; d \\ e &amp;
        f\end{bmatrix} = \begin{bmatrix}1a + 2c + 3e &amp; 1b + 2d + 3f \\4a +
        5c + 6e &amp; 4b + 5d + 6f \\7a + 8c + 9e &amp; 7b + 8d +
        9f\end{bmatrix}\]

        <p><strong>Multiplicative Identity</strong></p>
        <ul>
          <li>
            The multiplicative identiy matrix must:
            <ul>
              <li>Be a square matrix.</li>
              <li>
                Have a diagonal of 1s, from upper-left to lower-right corners.
              </li>
              <li>Have all otehr values be 0.</li>
            </ul>
          </li>
          <li>
            A \(4\times4\) identity matrix: \begin{bmatrix}1 &amp; 0 &amp; 0
            &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}
          </li>
        </ul>

        <h5 id="back-to-top-3"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="transformations">Transformations</h3>
        <p>
          In order to perform transformations, we will construct a
          <em>transformation matrix</em> \(F\), which can then be applied to our
          edge matrix \(E\) by matrix multiplication. By asserting that the
          order of multiplication is always \(FE\), we can constrain \(F\) to
          always be a \(4\times4\) matrix. For each transformation, it is
          helpful to think of it with the following framework:
        </p>
        <ul>
          <li>
            What information is required in order to perform the transformation?
          </li>
          <li>
            What happens to \((x, y, z)\) after the transformation is applied?
          </li>
        </ul>

        <p><strong>Translation</strong> or move</p>
        <ul>
          <li>
            Necessary information: Translation factors for each component, \((a,
            b, c)\)
          </li>
          <li>
            Function: \(T_{a, b, c} (x, y, z) \rightarrow (x+a, y+b, z+c)\)
          </li>
          <li>Matrix &amp; example:</li>
        </ul>

        \[\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; a \\\ 0 &amp; 1 &amp; 0 &amp;
        b \\\ 0 &amp; 0 &amp; 1 &amp; c \\\ 0 &amp; 0 &amp; 0 &amp; 1
        \end{bmatrix} \begin{bmatrix} x_0 &amp; x_1 \\ y_0 &amp; y_1 \\ z_0
        &amp; z_1 \\ 1 &amp; 1\end{bmatrix} = \begin{bmatrix} x_0 + a &amp; x_1
        + a \\y_0 + b &amp; y_1 + b \\z_0 + c &amp; z_1 + c \\ 1 &amp; 1
        \end{bmatrix}\]

        <ul>
          <li>
            <p>
              Note that this simple translation matrix is made possible by
              including the bottom row of 1s in our edge matrix. Without that,
              we’d have to include operations like: \(\dfrac{x + a}{x}\), which
              would in turn mean that the translation matrix would have to
              change for <em>every point</em> in the edge matrix, like so:
            </p>

            \[\begin{bmatrix} \frac{x_0+a}{x_0} &amp; 0 &amp; 0 \\\ 0 &amp;
            \frac{y_0+b}{y_0} &amp; 0 \\\ 0 &amp; 0 &amp; \frac{z_0+c}{z_0}
            \end{bmatrix} \begin{bmatrix} x_0 \\ y_0 \\ z_0 \end{bmatrix} =
            \begin{bmatrix} x_0 + a \\y_0 + b \\z_0 + c\end{bmatrix}\]
          </li>
        </ul>

        <p><strong>Dilation</strong> or scale</p>
        <ul>
          <li>
            Necessary information: Dilation factors for each component, \((a, b,
            c)\)
          </li>
          <li>Function: \(D_{a, b, c} (x, y, z) \rightarrow (ax, by, cz)\)</li>
          <li>
            <p>Matrix &amp; example:</p>

            \[\begin{bmatrix} a &amp; 0 &amp; 0 &amp; 0 \\\ 0 &amp; b &amp; 0
            &amp; 0 \\\ 0 &amp; 0 &amp; c &amp; 0 \\\ 0 &amp; 0 &amp; 0 &amp; 1
            \end{bmatrix} \begin{bmatrix} x_0 &amp; x_1 \\ y_0 &amp; y_1 \\ z_0
            &amp; z_1 \\ 1 &amp; 1 \end{bmatrix} = \begin{bmatrix} ax_0 &amp;
            ax_1 \\by_0 &amp; by_1 \\cz_0 &amp; cz_1 \\ 1 &amp; 1
            \end{bmatrix}\]
          </li>
          <li>
            Dilations intended to preserve the asptect ratio of the orginal
            image should use the same value for \(a\), \(b\), and \(c\). Using
            different values will resulting in stretching/squishing the image in
            verious dimentions.
          </li>
          <li>
            Dilations applied in this manner are also done with respect ot the
            origin. Eventually, this will be less of a concern, but for now, you
            can achieve arbitrary dilations by translating to the origin,
            dilating, and then translating back.
          </li>
        </ul>

        <p><strong>Rotation</strong></p>
        <ul>
          <li>
            Necessary information: Angle of rotation, \(\theta\) and axis of
            rotation.
          </li>
          <li>
            Figuring out the rotation function is a bit more complicated than
            the previous transformations.
          </li>
          <li>
            First let’s look at a translation about the z axis:
            <img src="../assets/img/n02-z_rotation.png" alt="axis" />
            <ul>
              <li>
                Since the point does not change along the axis of rotation, we
                only need to conern ourselves with \((x, y)\)
              </li>
              <li>
                We need to find a way to represent \((x',y')\) based on
                information we know.
              </li>
              <li>
                Using polar coordinates, we can re-write \((x, y)\) as
                \((rcos\phi, rsin\phi)\)
              </li>
              <li>
                Similarly, \((x', y')\) can be written as \((rcos(\phi+\theta),
                rsin(\phi+\theta))\)
              </li>
              <li>
                <p>
                  Using the angle sum formula, and the values for \((x, y)\)
                  above, we get the following:
                </p>

                \[x' = rcos(\phi + \theta) \quad y' = rsin(\phi + \theta)\] \[x'
                = rcos\phi cos\theta - rsin\phi sin\theta \quad y' = rsin\phi
                cos\theta + rcos\phi sin\theta\] \[x' = xcos\theta - ysin\theta
                \quad y' = ycos\theta + xsin\theta\]
              </li>
            </ul>
          </li>
          <li>
            z-axis rotation
            <ul>
              <li>
                Function: \(R_{\theta, z-axis} (x, y, z) \rightarrow
                (xcos\theta-ysin\theta, xsin\theta+ycos\theta,z)\)
              </li>
              <li>
                <p>Matrix &amp; example:</p>

                \[\begin{bmatrix} cos\theta &amp; -sin\theta &amp; 0 &amp; 0 \\\
                sin\theta &amp; cos\theta &amp; 0 &amp; 0 \\\ 0 &amp; 0 &amp; 1
                &amp; 0 \\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}
                \begin{bmatrix} x_0 \\ y_0 \\ z_0 \\ 1 \end{bmatrix} =
                \begin{bmatrix} x_0cos\theta-y_0sin\theta \\x_0sin\theta +
                y_0cos\theta \\z_0 \\ 1 \end{bmatrix}\]
              </li>
            </ul>
          </li>
          <li>
            x-axis rotation
            <ul>
              <li>
                Function: \(R_{\theta, x-axis} (x, y, z) \rightarrow (x,
                ycos\theta - zsin\theta, ysin\theta + zcos\theta)\)
              </li>
              <li>
                <p>Matrix &amp; example:</p>

                \[\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\ 0 &amp;
                cos\theta &amp; -sin\theta &amp; 0 \\\ 0 &amp; sin\theta &amp;
                cos\theta &amp; 0 \\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}
                \begin{bmatrix} x_0 \\ y_0 \\ z_0 \\ 1 \end{bmatrix} =
                \begin{bmatrix} x_0 \\y_0cos\theta - z_0sin\theta \\y_0sin\theta
                + z_0cos\theta \\ 1 \end{bmatrix}\]
              </li>
            </ul>
          </li>
          <li>
            y-axis rotation
            <ul>
              <li>
                Function: \(R_{\theta, y-axis} (x, y, z) \rightarrow
                (xcos\theta+zsin\theta, y, -xsin\theta + zcos\theta)\)
              </li>
              <li>
                <p>Matrix &amp; example:</p>

                \[\begin{bmatrix} cos\theta &amp; 0 &amp; sin\theta &amp; 0 \\\
                0 &amp; 1 &amp; 0 &amp; 0 \\\ -sin\theta &amp; 0 &amp; cos\theta
                &amp; 0 \\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}
                \begin{bmatrix} x_0 \\ y_0 \\ z_0 \\ 1 \end{bmatrix} =
                \begin{bmatrix} x_0cos\theta+z_0sin\theta \\y_0 \\-x_0sin\theta
                + z_0cos\theta \\ 1 \end{bmatrix}\]
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Combining Transformations</strong></p>
        <ul>
          <li>
            Let’s say we have the following matrices:
            <ul>
              <li>\(E_0\): Edge matrix</li>
              <li>\(T\): Translation</li>
              <li>\(D\): Dilation</li>
              <li>\(R\) Rotation</li>
            </ul>
          </li>
          <li>
            And we perform the following operations to generate new edge
            matrices:
            <ul>
              <li>\(E_1 = TE_0\): \(E_0\), moved</li>
              <li>\(E_2 = DE_1\): \(E_0\), moved, then scaled</li>
              <li>\(E_3 = RE_2\): \(E_0\), moved, then scaled, then rotated</li>
              <li>
                Substituting back up this chain, we get:
                <ul>
                  <li>
                    \(E_3 = RDTE_0\) Becuse matrix multiplication is
                    <em>associative</em>, we can write this as:
                  </li>
                  <li>
                    \(E_3 = (RDT)E_0\) Which means that we can generate the same
                    image by multipling transformation matrices with each other
                    <em>then</em> multiplying by an edge matrix as we could by
                    multiplying the edge matrix by each transformation matrix
                    <em>separately</em>.
                  </li>
                  <li>
                    This could save lots of time, since all transformation
                    matrices are \(4\times4\), while our edge matrices are
                    \(4\times N\).
                  </li>
                </ul>
              </li>
              <li>
                The order is important. Note that:
                <ul>
                  <li>\((RDT)E_0\) is not the same as</li>
                  <li>
                    \((TDR)E_0\) because matrix multiplication is not
                    commutative.
                  </li>
                  <li>
                    The first image would be the reslut of moving, scaling, then
                    rotating. The second would be the result of rotating,
                    scaling, then moving.
                  </li>
                  <li>
                    It is common (since most of us are used to reading
                    left-&gt;right), to think about the appilcation of
                    transformations that way.
                    <strong><em>You have been warned</em></strong
                    >.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <h5 id="back-to-top-4"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="parametric-equations">Parametric Equations</h3>
        <p>
          Parametric equations can be used to caluculate the components of the
          points along a cuve as a function of an independent variable (commonly
          referred to as \(t\)). For example, let’s say we want to draw a line
          from \((x_0, y_0)\) to \((x_1, y_1)\). We can define this
          parametrically as:
        </p>

        \[\begin{aligned} x = x_0 + (x1 - x0)t \\ y = y_0 + (y1 - y0)t
        \end{aligned}\]

        <p>
          At \(t = 0\), we just get \((x_0, y_0)\) and at \(t = 1\), we get
          \((x_1, y_1)\). As \(t\) moves over the range \(0\rightarrow1\), these
          equations will generate all the points along the line. We already have
          a very good way of drawing a line, but we <em>can</em> generalize this
          process for other shapes:
        </p>

        \[\begin{aligned} t: 0\rightarrow1 \\ x = f(t) \\ y = g(t)
        \end{aligned}\]

        <p>
          By using the framework above to generate points that we can add to our
          edge matrices, we can draw any shape that can be defined in such a
          manner.
        </p>
        <ul>
          <li>
            <p>
              Parametric circle with radius \(r\) and center \((c_x, c_y)\):
            </p>

            \[\begin{aligned} t: 0\rightarrow1 \\ x = rcos(2\pi t) + c_x \\ y =
            rsin(2\pi t) + c_y \end{aligned}\]
          </li>
        </ul>

        <h5 id="back-to-top-5"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="splines">Splines</h3>
        <p>
          Splines are a special set of polynomial curves. They are designed in
          such a way that you can combine 2 or more splines smoothly in order to
          generate higher degree curves. You may recall the term
          <a href="https://en.wikipedia.org/wiki/Flat_spline">spline</a> from
          your drafting days, using splines to make non-arc based curves. In
          Computer Graphics, splines are an effective way of generating
          arbitrary curves effeciently. We will only need to create 3rd degree
          curves at most, but still be able to generate more complex looking
          ones by combining splines.
        </p>

        <p>
          Remember that our purpose is to make a graphics engine, and
          <em>not</em> a graphing calcuator. So when thinking about drawing
          arbitrary polynomials, we have to think about what information is
          useful to us. Think about a circle, in order to draw one, we would
          like to know the center and radius. Turns out, that information not
          only describes the shape we’re drawing, but also goes directly into
          the parametric equations for making a circle. It is also easy to
          provide that information via a GUI (click center, drag for radius,
          boom). A standard 3rd degree polynomial, \(ax^3 + bx^2 + cx + d\)
          doesn’t trasnlate as easily into the graphical world. Think about
          drawing a line, we specify <em>endpoints</em> and generate the
          equation based on that. We will look at two types of splines,
          <em>Hermite</em> and <em>Bezier</em> curves, which are similar (in
          fact, you can translate between the two), but differ in the
          information required to generate a cruve.
        </p>

        <p><strong>Hermite Curves</strong></p>
        <ul>
          <li>
            Given information:
            <ul>
              <li>\(P_0, P_1\): endpoints</li>
              <li>\(R_0, R_1\): rates of change at each endpoint.</li>
              <li>
                \(P_0, P_1\) designate where the curve starts and ends.
                Specifying rates of change at each endpoint allows us to both
                generate curves between the endpoints, but also connect multiple
                curves smoothly. Two Hermite curves that share a common endpoint
                <em>and</em> rate of change at that endpoint will nicely connect
                to create a larger, more complex cure.
              </li>
              <li>
                We will use parametric equations to help get from this
                information to points along a curve.
              </li>
            </ul>
          </li>
          <li>
            Parametric framework: \(t: 0 \rightarrow 1\)
            <ul>
              <li>
                \(f(t) = at^3 + bt^2 + ct + d\) Standard cubic equation,
                substituting for \(t\) will generate points along our curve.
                <ul>
                  <li>
                    Ultimately, this is the equation we need to make a curve, so
                    we will need to calculate the coeficients based on the given
                    information.
                  </li>
                  <li>
                    N.B. In order to actually make a curve, we will need
                    separate functions for \(x\) and \(y\), such that \(f_x(t) =
                    x\) and \(f_y(t) = y\). Since the math is identical for
                    both, We will just look at \(f(t)\) in general.
                  </li>
                </ul>
              </li>
              <li>
                \(f'(t) = 3at^2 + 2bt + c\) Derivative of \(f\). After checking
                with Mr. Cocoros, I am certain that substituting for \(t\) will
                generate the rates of change along the curve defined by \(f\).
              </li>
              <li>
                When \(t = 0\):
                <ul>
                  <li>\(f(0) = d\) which corresponds to \(P_0\)</li>
                  <li>\(f'(0) = c\) which corresponds to \(R_0\)</li>
                </ul>
              </li>
              <li>
                When \(t = 1\):
                <ul>
                  <li>\(f(1) = a + b + c + d\) which corresponds to \(P_1\)</li>
                  <li>\(f'(1) = 3a + 2b + c\) which corresponds to \(R_1\)</li>
                </ul>
              </li>
              <li>
                <p>
                  Now we have 4 unknowns, and 4 equations, you may recall this
                  from math as a <em>systems of equations</em> problem. There
                  are many ways to deal with this, but since we’re already in
                  graphics, let’s use matrices!
                </p>

                \[\begin{array}{c} H \\ \left[ \begin{matrix} 0 &amp; 0 &amp; 0
                &amp; 1 \\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\ 0 &amp; 0 &amp; 1
                &amp; 0 \\\ 3 &amp; 2 &amp; 1 &amp; 0 \end{matrix} \right]
                \end{array} \begin{array}{c} C \\ \left[ \begin{matrix} a \\\ b
                \\\ c \\\ d \end{matrix} \right] \end{array} = \begin{array}{c}
                \\ \left[ \begin{matrix} d \\\ a + b + c + b \\\ c \\\ 3a + 2b +
                c \end{matrix} \right] \end{array} = \begin{array}{c} G \\
                \left[ \begin{matrix} P_0 \\\ P_1 \\\ R_0 \\\ R_1 \end{matrix}
                \right] \end{array}\]
              </li>
              <li>
                So multiplying the special Hermite matrix, \(H\) by the
                Coeficient matrix \(C\), reuslts in the Given information \(G\).
                Of course, the problem here is that we
                <em>DONT KNOW THE COEFICIENTS</em>. Never fear, divison (or
                rather, multiplying by the multiplicative inverse), is here!.
              </li>
              <li>
                <p>
                  \(HC = G\), so \(H^{-1}G = C\). We just need the inverse of
                  \(H\), which I just happen to have right here:
                </p>

                \[H^{-1} = \begin{bmatrix} 2 &amp; -2 &amp; 1 &amp; 1 \\\ -3
                &amp; 3 &amp; -2 &amp; -1 \\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\ 1
                &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}\]
              </li>
              <li>
                \(H^{-1}G\) will give us the coeficients to fill out \(f(t) =
                ax^3 + bx^2 + cx + d\), so that we can loop to from 0 to 1 to
                generate the points along our Hermite curve. <em>Et viola!</em>
                <strong>Bezier Curves</strong>
              </li>
            </ul>
          </li>
          <li>
            Given information:
            <ul>
              <li>\(P_0, P_3\): endpoints</li>
              <li>\(P_1, P_2\): “control” points</li>
              <li>
                \(P_0, P_1\) designate where the curve starts and ends. \(P_1,
                P_2\) are points that influence the shape of the curve as we
                move between endpoints.
              </li>
              <li>
                We will use parametric equations to help get from this
                information to points along a curve.
              </li>
            </ul>
          </li>
          <li>
            In general, in order to create a Bezier curve of degree \(n\), we
            need \(n+1\) points.
          </li>
          <li>
            <strong>Bezier Line</strong>
            <ul>
              <li>
                <span style="display: flex">
                  In order to understand higher order Bezier curves, let’s start
                  with the simplest, the line. Graphically, a Bezier line can be
                  generated by linerarly moving between the endpoints like so:
                  <img src="../assets/img/n04-bez_1.gif" alt="1_bez" />
                </span>
              </li>
              <li>
                Algebraically, we can write this as: \(L = (1-t)P_0 + tP_1\)
              </li>
            </ul>
          </li>
          <li>
            <strong>Bezier Quadratic</strong>
            <ul>
              <li>
                <span style="display: flex">
                  A quadratic needs one more point than the line. This creates 2
                  normal lines, that we move along in the standard fashion. This
                  creates a series of endpooints that we can use to create a new
                  line (pictured in green). As we move along each static line,
                  we also move along the dynamic line, which in turn generates
                  the points on our quadratic curve.
                  <img src="../assets/img/n04-bez_2.gif" alt="2_bez"
                /></span>
              </li>
              <li>
                Since the quadratic is generated by moving across a line, we
                could represent it as: \(Q = (1-t)L_0 + tL_1\)
              </li>
              <li>
                <p>
                  But \(L_1, L_0\) are not points, they’re lines. Substituting
                  in the linear equation, we get:
                </p>

                \[\begin{aligned} Q &amp;= (1-t)[(1-t)P_0+tP_1] +
                t[(1-t)P_1+tP_2] \\ Q &amp;= (1-t)^2P_0 + t(1-t)P_1 + t(1-2)P_1
                + t^2P_2 \\ Q &amp;= (1-t)^2P_0 + 2t(1-t)P_1 + t^2P_2
                \end{aligned}\]
              </li>
            </ul>
          </li>
          <li>
            <strong>Bezier Cubic</strong>
            <ul>
              <li>
                <span style="display: flex">
                  Just as a quadratic is made from 2 linear bezier cuves, a
                  cubic is generated by moving along a line whose endpoints
                  would generate 2 quadratic curves. The blue line generates the
                  cubic, and its endpoints march along the green lines, which in
                  turn march along the staic gray lines connecting all the input
                  points. <img src="../assets/img/n04-bez_3.gif" alt="3_bez"
                /></span>
              </li>
              <li>
                Since the cubic is generated by moving across a line, we could
                represent it as: \(C = (1-t)Q_0 + tQ_1\)
              </li>
              <li>
                <p>
                  But \(Q_1, Q_0\) are not points, they’re quadratics.
                  Substituting in the quadratic bezier equations is a bit
                  uglier, though the keen observer may have noticed these
                  equations follow the binomial expansion…
                </p>

                \[\begin{aligned} C &amp;= (1-t)[(1-t)^2P_0 + 2t(1-t)P_1 +
                t^2P_2] + t[(1-t)^2P_1 + 2t(1-t)P_2 + t^2P_3] \\ C &amp;=
                (1-t)^3P_0 + 3t(1-t)^2P_1 + 3t^2(1-t)P_2 + t^3P_3
                \end{aligned}\]
              </li>
              <li>
                <p>
                  Now we have an equation \(C\), that will generate points along
                  a cubic Bezier curve, but \(t\) is spread throughout the
                  equation. With a little more algebra we can get to:
                </p>

                \[C = (-P_0 + 3P_1 - 3P_2 + P_3)t^3 + (3P_0 - 6P_1 + 3P_2)t^2 +
                (-3P_0 + 3P_1)t + P_0\]
              </li>
              <li>
                This is a cubic of the form \(at^3 + bt^2 + ct + d\), that we
                can put into a parametric loop, the same way we generated
                Hermite curves. In fact, if we wanted to, we could use our
                existing matrix multiplication framework to generate the
                coeficients based on the given information (this is not a
                necessary step)
              </li>
            </ul>

            \[\begin{array}{c} B \\ \left[ \begin{matrix} -1 &amp; 3 &amp; -3
            &amp; 1 \\\ 3 &amp; -6 &amp; 3 &amp; 0 \\\ -3 &amp; 3 &amp; 0 &amp;
            0 \\\ 1 &amp; 0 &amp; 0 &amp; 0 \end{matrix} \right] \end{array}
            \begin{array}{c} G \\ \left[ \begin{matrix} P_0 \\\ P_1 \\\ P_2 \\\
            P_3 \end{matrix} \right] \end{array} = \begin{array}{c} \\ \left[
            \begin{matrix} -P_0 + 3P_1 - 3P_2 + P_3 \\\ 3P_0 - 6P_1 + 3P_2 \\\
            -3P_0 + 3P_1 \\\ P_0 \end{matrix} \right] \end{array} =
            \begin{array}{c} C \\ \left[ \begin{matrix} a \\\ b \\\ c \\\ d
            \end{matrix} \right] \end{array}\]
          </li>
        </ul>

        <h5 id="back-to-top-6"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="3d-shapes">3D Shapes</h3>

        <p>We will be working with the following 3D shapes:</p>
        <ul>
          <li>Box, Sphere, Torus</li>
          <li>
            There are many other 3D shapes that could be easily generated
            programmatic, these specific three allow us to work with and test
            many advanced features, especially when it comes to lighting &amp;
            shading. If you want to add more shapes, keep that idea as a feature
            to be added to your final project.
          </li>
          <li>
            For each shape, we want to start by considering 2 important
            questions:
            <ol>
              <li>What given information should we require?</li>
              <li>
                What are the points that our engine will need to generate in
                order to draw the shape?
                <ul>
                  <li>
                    The goal of our engine will be to create the necessary
                    points from the given information (this is how we created
                    circles &amp; splines as well).
                  </li>
                </ul>
              </li>
            </ol>
          </li>
        </ul>

        <p><strong>Box</strong></p>
        <ul>
          <li>
            Given Information:
            <ol>
              <li>
                A vertex: for consistency, we will be using the
                <strong>left-top-front</strong> vertex.
              </li>
              <li>Width: Size in the <strong>x</strong> dimension</li>
              <li>Height: Size in the <strong>y</strong> dimension</li>
              <li>Depth: Size in the <strong>z</strong> dimension</li>
            </ol>
          </li>
          <li>
            Defining Points:
            <ul>
              <li>The 8 vertices of the box.</li>
            </ul>
          </li>
          <li>
            Once you have the 8 vertices, you can directly add the 12 edges that
            make up the box. You don’t need to do anything fancy here.
          </li>
        </ul>

        <p><strong>Sphere</strong></p>
        <ul>
          <li>
            Given Information:
            <ol>
              <li>Center</li>
              <li>Radius</li>
            </ol>
          </li>
          <li>
            Defining Points:
            <ul>
              <li>Points on the surface of the sphere.</li>
            </ul>
          </li>
          <li>
            Point Generation
            <ul>
              <li>
                The points on the surface of a sphere can be generated by taking
                a circle and rotating it. Each circle rotation creates a new
                “slice” of the sphere.
              </li>
              <li>
                <p>
                  The circle can be rotated about the x or y axes, but not z.
                  The only difference will be the location of the “poles” of the
                  sphere. An x-rotated sphere will have its poles on the left
                  and right ends, while a y-rotated sphere will have its poles
                  on the top and bottom.
                </p>

                \[\begin{array}{c} x rotation \\ \left[ \begin{matrix} 1 &amp; 0
                &amp; 0 \\\ 0 &amp; cos(\phi) &amp; -sin(\phi) \\\ 0 &amp;
                sin(\phi) &amp; cos(phi) \end{matrix} \right] \end{array}
                \begin{array}{c} circle \\ \left[ \begin{matrix} rcos(\theta)
                \\\ rsin(\theta) \\\ 0 \end{matrix} \right] \end{array} =
                \begin{array}{c} sphere \\ \left[ \begin{matrix} rcos(\theta)
                \\\ rsin(\theta)cos(\phi) \\\ rsin(\theta)sin(\phi) \end{matrix}
                \right] \end{array}\]
              </li>
              <li>
                <p>
                  The matrix multiplication above leaves us with equations that
                  we can use to find the points of a sphere:
                </p>

                \[\begin{aligned} x &amp;= rcos(\theta) + C_x \\ y &amp;=
                rsin(\theta)cos(\phi) + C_y \\ z &amp;= rsin(\theta)sin(\phi) +
                C_z \end{aligned}\]
              </li>
              <li>
                Here \(\phi\) is used as the angle of rotation and \(\theta\) is
                used as the angle odf circle creation. If you only use one
                angle, then you would generate one point per circle each
                rotation. The resulting shape would be a sprial going along the
                sphere (pleasing, but not our goal).
                <ul>
                  <li>
                    You can generate a sphere either by creating a full circle
                    and rotating it π radians, or by creating a semi-circle and
                    rotating it 2π radians. For reasons that will become clear
                    later, it is to our advantage to use the semi-circle method.
                  </li>
                </ul>
              </li>
              <li>
                With these equations we can create a nested-loop parametric
                function to generate all the points on a circle:
                <div class="language-plaintext highlighter-rouge">
                  <div class="highlight">
                    <pre class="highlight"><code>for rot: 0 -&gt; 1
  for cir: 0 -&gt; 1
    x = r * cos(π * cir) + Cx
    y = r * sin(π * cir) * cos(2π * rot) + Cy
    z = r * sin(π * cir) * sin(2π * rot) + Cz
</code></pre>
                  </div>
                </div>
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Torus</strong></p>
        <ul>
          <li>
            Given Information:
            <ol>
              <li>Center</li>
              <li>Radius of circular cross-section (r)</li>
              <li>
                Distance for torus center to center of the cross-section (R)
              </li>
            </ol>
          </li>
          <li>
            Defining Points:
            <ul>
              <li>Points on the surface of the torus.</li>
            </ul>
          </li>
          <li>
            A torus (donut, bagel), can be generated in a similar way to a
            sphere, except you move the circle away from the torus center before
            rotating.
          </li>
          <li>
            Here you have to be careful about how you move the circle and then
            rotate it. Only specific combinations will work:
            <ul>
              <li>
                Move a circle horizontally (x translation) and y rotation.
              </li>
              <li>
                <p>Move a circle vertically (y translation) and x rotation.</p>

                \[\begin{array}{c} y rotation \\ \left[ \begin{matrix} cos(\phi)
                &amp; 0 &amp; sin(\phi) \\\ 0 &amp; 1 &amp; 0 \\\ -sin(\phi)
                &amp; 0 &amp; cos(phi) \end{matrix} \right] \end{array}
                \begin{array}{c} circle \\ \left[ \begin{matrix} rcos(\theta) +
                R \\\ rsin(\theta) \\\ 0 \end{matrix} \right] \end{array} =
                \begin{array}{c} sphere \\ \left[ \begin{matrix}
                cos(\phi)(rcos(\theta) + R) \\\ rsin(\theta) \\\
                -rsin(\phi)(rcos(\theta) + R) \end{matrix} \right] \end{array}\]

                <p>```</p>
              </li>
              <li>
                <p>
                  The matrix multiplication above leaves us with equations that
                  we can use to find the points of a torus:
                </p>

                \[\begin{aligned} x &amp;= cos(p) * (rcos(t) + R) + C_x \\ y
                &amp;= rsin(t) + C_y \\ z &amp;= -sin(p) * (rcos(t) + R) + C_z
                \end{aligned}\]
              </li>
              <li>
                Unlike the sphere, you will draw a complete circle for each
                rotation.
              </li>
            </ul>
          </li>
        </ul>

        <h5 id="back-to-top-7"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="using-polygons">Using Polygons</h3>
        <p>Wire-frame Models</p>
        <ul>
          <li>
            Currently, our basic unit of drawing is a line. When we create a
            shape, we add edges to an edge matrix, and we loop through that
            matrix drawing lines.
          </li>
          <li>
            A 3D shape rendered using edges only has no real surface to speak
            of. Instead, it is a
            <a
              href="https://en.wikipedia.org/wiki/Wire-frame_model"
              target="_blank"
              >wire-frame model</a
            >. Wire-frame models can be rendered quickly, but because they lack
            true surface, there are limits to how realistic they can look.
          </li>
        </ul>

        <p>Polygon Meshes</p>
        <ul>
          <li>
            If we change our basic unit of drawing form a line to a polygon, we
            will have surfaces to work with, generating a
            <a href="https://en.wikipedia.org/wiki/Polygon_mesh" target="_blank"
              >polygon mesh</a
            >
          </li>
          <li>
            Having a surface gives us more options when rendering 3D objects.
            Most notably:
            <ul>
              <li>
                Polygons can be filled with colors, creating solid objects.
              </li>
              <li>
                We can describe polygons as “facing” a particular direction, and
                use that information to determine sides of our 3D shapes that
                are facing away from the viewer and should therefore not be
                rendered.
              </li>
            </ul>
          </li>
          <li>
            There are many possible shapes we could use as our basic polygons,
            we will use triangles, as they are the simplest polygon.
          </li>
        </ul>

        <p>Polygon Lists</p>
        <ul>
          <li>
            Our current shapes are all based on <em>edge lists</em>, where every
            2 points determine a distinct edge to be drawn.
          </li>
          <li>
            We should keep this framework around in order to draw 2 dimensional
            shapes when desired.
          </li>
          <li>
            <p>
              We need to add <em>polygon lists</em>, where every 3 points
              determine a distinct triangle. Here is a chart comparing the
              functions in our 2D, edge based, drawing stack and their 3D,
              polygon based, equivalents.
            </p>

            <table>
              <thead>
                <tr>
                  <th>Edge Framework</th>
                  <th>Polygon Framework</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <code class="language-plaintext highlighter-rouge"
                      >add_point</code
                    ><br />Add a point to the edge list
                  </td>
                  <td>
                    <code class="language-plaintext highlighter-rouge"
                      >add_point</code
                    ><br />Add a point to the polygon list
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="language-plaintext highlighter-rouge"
                      >add_edge</code
                    ><br />Add the endpoints of a line to the edge list.
                  </td>
                  <td>
                    <code class="language-plaintext highlighter-rouge"
                      >add_polygon</code
                    ><br />Add the three vertices of a triangle into the polygon
                    list.<br />The vertices must be added in
                    <strong>counter-clockwise</strong> order*.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="language-plaintext highlighter-rouge"
                      >draw_lines</code
                    ><br />Go through the edge list 2 points at a time, drawing
                    a line between each pair of points.
                  </td>
                  <td>
                    <code class="language-plaintext highlighter-rouge"
                      >draw_polygons</code
                    ><br />Go through the polygon list 3 points at a time,
                    connecting the points to draw a triangle.<br />Other polygon
                    features can be added here later.
                  </td>
                </tr>
              </tbody>
            </table>
          </li>
          <li>
            By adding the points in counter-clockwise order, we will be able to
            eventually determine what is <em>forwards</em> and
            <em>backwards</em> with respect to the triangle. This will help us
            implement more advanced features later.
          </li>
        </ul>

        <h3 id="polygon-based-shapes">Polygon Based Shapes</h3>
        <p><strong>Box</strong></p>
        <ul>
          <li>A box has 6 faces, each one made up of 2 triangles.</li>
          <li>
            Like before, the easiest thing to do here is add your 12 triangles
            directly into the polygon list.
          </li>
          <li>
            The order of the triangles does not matter, but
            <strong>the order of the points does</strong>. Points should always
            be added <strong>counter-clockwise</strong>.
          </li>
        </ul>

        <p><strong>Sphere</strong></p>
        <ul>
          <li>
            We generate spheres by drawing a series of rotated semi-circles. If
            you followed my advice, you should have a separate
            <code class="language-plaintext highlighter-rouge"
              >generate_sphere</code
            >
            function that returns a matrix of points for the sphere.
          </li>
          <li>
            Our job now is to go through that list of points, adding triples of
            points representing the triangles on the surface of the sphere to
            our polygon list.
          </li>
          <li>
            The best thing to do is physically draw the first two semicircles
            generated by your code, and write out what triangles are required.
            Like so:
            <img
              src="../assets/img/n00-sphere_points.png"
              alt="sphere points"
            />
          </li>
          <li>
            When drawing semi-circles, you need to generate the poles, which are
            created when
            <code class="language-plaintext highlighter-rouge">t=0</code> and
            <code class="language-plaintext highlighter-rouge">t=1</code>,
            respectively. This is different from drawing full circles, you don’t
            need to include
            <code class="language-plaintext highlighter-rouge">t=1</code> there
            because the point at
            <code class="language-plaintext highlighter-rouge">t=1</code> is
            identical to the point at
            <code class="language-plaintext highlighter-rouge">t=0</code>.
          </li>
          <li>
            The way my loops are written, this means when I set steps to 10 I
            actually get 11 points per semi-circle.
          </li>
          <li>
            It is also important to keep track of the direction your
            semi-circles are drawn in. If you used the example from class
            (semi-circles rotated about the x-axis), then each new semi-circle
            is drawn in front of/below the previous one (the video may help
            demonstrate this).
          </li>
          <li>
            Here are some of the triangles taken from this diagram:
            <div class="language-plaintext highlighter-rouge">
              <div class="highlight">
                <pre class="highlight"><code>0: p0, p1, p12
--------------
1: p1, p2, p13
2: p1, p13, p12
</code></pre>
              </div>
            </div>
          </li>
          <li>
            At the poles, there is only one triangle to add per section, this is
            triangle 0 above.
          </li>
          <li>
            Otherwise, triangles are added in pairs, as is shown by triangles 1
            and 2.
            <ul>
              <li>
                If
                <code class="language-plaintext highlighter-rouge">n</code> is
                the number of points in a semi-circle, then we can define the
                triangles for the non-poles as:
                <div class="language-plaintext highlighter-rouge">
                  <div class="highlight">
                    <pre class="highlight"><code>p, p + 1, (p + n) + 1
p, (p + n) + 1, p + n
</code></pre>
                  </div>
                </div>
              </li>
              <li>
                At the poles, we need to make sure not to add both triangles.
                Following the above formulae, at
                <code class="language-plaintext highlighter-rouge">p=0</code>,
                we would have triangles
                <code class="language-plaintext highlighter-rouge"
                  >0, 1, 12</code
                >
                and
                <code class="language-plaintext highlighter-rouge"
                  >0, 12, 11</code
                >. But for the second triangle,
                <code class="language-plaintext highlighter-rouge">0</code> and
                <code class="language-plaintext highlighter-rouge">11</code> are
                the same point. This would render as a straight line, which
                might not seem like a big deal, but having these “degenerate”
                triangles at the poles will cause problems down the line, so
                it’s best to exclude them now.
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Torus</strong></p>
        <ul>
          <li>
            Torus creation is very similar to the sphere, with a couple of
            changes.
            <ul>
              <li>Tori must be generated with full circles.</li>
              <li>
                No 2 circles of a torus share any common points, which means we
                don’t have <em>poles</em>. This actually makes it easier to code
                since we don’t have those special cases.
              </li>
              <li>
                The tori from class are generated by rotating about the y-axis.
                This means that each new circle is drawn
                <strong>behind</strong> the previous one.
              </li>
            </ul>
          </li>
          <li>
            As with the sphere, it is advised that you draw out the first two
            slices of torus to map out the appropriate triangles.
          </li>
        </ul>

        <h5 id="back-to-top-8"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="backface-culling">Backface Culling</h3>

        <h4 id="vectors">Vectors</h4>
        <p>
          A
          <a
            href="https://en.wikipedia.org/wiki/Euclidean_vector"
            target="_blank"
            >vector</a
          >
          is a unit that has both direction and magnitude (size).
        </p>

        <p>
          Vectors are written like so:
          <code class="language-plaintext highlighter-rouge"
            >&lt;x, y, z&gt;</code
          >
        </p>
        <ul>
          <li>
            Notice that vector components are placed inside
            <code class="language-plaintext highlighter-rouge">&lt;&gt;</code>
            to differentiate them from points.
          </li>
        </ul>

        <p>
          A point only describes a single point in space, whereas a vector
          describes a relationship between 2 points (often, not always, an
          arbitrary point and the origin)
        </p>

        <p>
          You can think of a vector as describing how you would get from point A
          to point B.
        </p>
        <ul>
          <li>
            For example, consider the following two points,
            <code class="language-plaintext highlighter-rouge"
              >p0: (4, 10, 0)</code
            >
            and
            <code class="language-plaintext highlighter-rouge"
              >p1: (6, 5, 23)</code
            >
          </li>
          <li>
            To get from
            <code class="language-plaintext highlighter-rouge">p0</code> to
            <code class="language-plaintext highlighter-rouge">p1</code>, you
            would have to move +2 in x, -5 in y and +23 in z, so we would write
            the vector as:
            <code class="language-plaintext highlighter-rouge"
              >&lt;2, -5, 23&gt;</code
            >
          </li>
          <li>
            The vector from
            <code class="language-plaintext highlighter-rouge">p1</code> to
            <code class="language-plaintext highlighter-rouge">p0</code> moves
            in the opposite direction, and would be written as
            <code class="language-plaintext highlighter-rouge"
              >&lt;-2, 5, -23&gt;</code
            >
          </li>
        </ul>

        <p>
          Generally, you can find the vector between 2 points by subtraction.
        </p>

        <p>
          Notationally, vectors are written with a \(\rightarrow\); like so:
          \(\overrightarrow{A}\);
        </p>

        <h4 id="backface-culling-1">Backface Culling</h4>
        <p>
          At any given viewing angle, you can only see at most half of the 3D
          shapes we are working with. The back side of a shape is entirely
          blocked by the front.
        </p>

        <p>
          If we could reasonably determine which polygons were facing backwards,
          then we could ignore them entirely, reducing the number of polygons we
          need to render by half.
        </p>
        <ul>
          <li>
            Right now that may not seem like much, but eventually this will save
            a lot of work. Down the line, to get the most realistic looking
            images, we will have to perform lighting calculations on a
            <em>per pixel</em> basis.
          </li>
        </ul>

        <p>
          Backface culling is the process of removing the backwards facing
          surfaces from our rendering engine. In order to do this, we need to
          define 2 vectors:
        </p>
        <ol>
          <li>
            \(\overrightarrow{N}\): The surface normal
            <ul>
              <li>
                This is a vector perpendicular to the plane of the polygon (or
                surface), pointing outward.
              </li>
            </ul>
          </li>
          <li>
            \(\overrightarrow{V}\): The view vector
            <ul>
              <li>
                This is a vector pointing out from the plane of the polygon (or
                surface) into the “eye” of the observer.
                <img
                  src="../assets/img/n01-backface_culling.png"
                  alt="backface culling"
                />
                <ul>
                  <li>
                    (The fireball-looking thing in the picture above is meant to
                    be an eye)
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>

        <p>
          We can tell if a surface is front or back facing based on the value of
          \(\theta\), the angle between \(\overrightarrow{N}\) and
          \(\overrightarrow{V}\).
        </p>
        <ul>
          <li>
            When \(-90 &lt; \theta &lt; 90\), then the surface is visible to the
            observer. Outside of that range, the surface is pointing away from
            the observer and is thus a backface.
          </li>
        </ul>

        <p>
          While it is referred to as backface culling, this process could be
          more accurately described as frontface including. We don’t actually
          remove the backfaces from our polygon lists (if we rotate the shape,
          then those faces may no longer be back facing!), rather, we check and
          only draw the polygons facing forward.
        </p>

        <p>Overview of backface culling</p>
        <ol>
          <li>Calculate \(\overrightarrow{N}\);</li>
          <li>Calculate \(\theta\);</li>
          <li>IF \(-90 &lt; \theta &lt; 90\), draw the triangle.</li>
        </ol>

        <p><strong>Calculate \(\overrightarrow{N}\)</strong></p>
        <ul>
          <li>
            We can find the surface normal by taking the cross product of two
            vectors along the edges of the polygon provided that they share one
            endpoint and point in opposite directions.
            <img
              src="../assets/img/n02-surface_normal.png"
              alt="surface normal"
            />
          </li>
          <li>
            <p>
              In the above diagram, \(\overrightarrow{A}\) is the vector from P0
              to P1 and \(\overrightarrow{B}\); is the vector from P0 to P2
            </p>

            \[\begin{aligned} \overrightarrow{A} &amp;= P_1 - P_0 = &lt;x_1 -
            x_0, y_1 - y_0, z_1 - z_0&gt; \\ \overrightarrow{B} &amp;= P_2 - P_0
            = &lt;x_2 - x_0, y_2 - y_0, z_2 - z_0&gt; \\ \overrightarrow{N}
            &amp;= \overrightarrow{A} \times \overrightarrow{B} \\
            \overrightarrow{N} &amp;= &lt;a_yb_z - a_zb_y, a_zb_x - a_xb_z,
            a_xb_y - a_yb_x&gt; \end{aligned}\]
          </li>
        </ul>

        <p><strong>Calculate θ</strong></p>
        <ul>
          <li>
            Before we figure out \(\theta\), we need to discuss the
            <em>view vector</em> (\(\overrightarrow{V}\))
            <ul>
              <li>
                \(\overrightarrow{V}\) is supposed to be a vector that comes out
                of the plane of the surface and into the observer. So the
                question is, what is the relationship between the observer and
                the surface?
                <ul>
                  <li>
                    For right now, we will assume that the observer is very very
                    very far away from the object. This assumption means that
                    moving left, right, up or down will not have any perceptible
                    effect on what part of the object you are looking at.
                  </li>
                  <li>
                    Think about looking up at the moon, if you move around, you
                    don’t start to see a new part of the moon. It looks the
                    same, even if you went from Staten Island up to the Bronx,
                    the moon would look the same.
                  </li>
                </ul>
              </li>
              <li>
                This means that we can ignore any changes along the x or y axes,
                but what about z?
              </li>
              <li>
                z is the important one, since that determines if you are in
                front of or behind the object. Remember that z moves in a
                positive direction out from the screen towards the viewer, so
                \(\overrightarrow{V}\), the vector from the object to the
                viewer, should have a positive z component.
              </li>
              <li>
                For right now \(\overrightarrow{V} = &lt;0, 0, 1&gt;\)
                <ul>
                  <li>
                    We don’t care about changes in x and y, so leaving them at 0
                    is fine.
                  </li>
                  <li>We need a positive z.</li>
                  <li>
                    By giving z the value of 1, the total mangnitude of
                    \(\overrightarrow{V}\) is 1. This is referred to as a
                    <em>normalized</em> vector. It’s not very important right
                    now, but it will be later on, so we might as well start
                    here.
                  </li>
                  <li>
                    We will not be looking at changing \(\overrightarrow{V}\)
                    for now, but you can think about what that would mean for
                    the rendered image and what effects that might lead to.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Now that we know both \(\overrightarrow{N}\) and
            \(\overrightarrow{V}\), there’s a little bit of vector math we can
            use to our advantage.
            <ul>
              <li>
                Dot product to the rescue: \(\overrightarrow{N} \cdot
                \overrightarrow{V} = Mcos\theta\)
                <ul>
                  <li>
                    The
                    <em
                      ><a
                        href="https://www.mathsisfun.com/algebra/vectors-dot-product.html"
                        target="_blank"
                        >dot product</a
                      ></em
                    >
                    of \(\overrightarrow{N}\) and \(\overrightarrow{V}\) is a
                    <em>scalar</em> (not a vector) value equal to the cosine of
                    the angle between them times the product of each vector’s
                    magnitude (\(M\)). You can calculate the dot product like
                    so:
                    <ul>
                      <li>
                        \[\overrightarrow{N} \cdot \overrightarrow{V} =
                        Mcos\theta = n_xv_x + n_yv_y + n_zv_z\]
                      </li>
                    </ul>
                  </li>
                  <li>
                    If we think about the properties of \(cos\theta\), this is
                    incredibly useful.
                  </li>
                  <li>
                    \(cos\theta &gt; 0\) when \(-90 &lt; \theta &lt; 90\)
                    <ul>
                      <li>This is exactly what we want.</li>
                    </ul>
                  </li>
                  <li>
                    Turns out, we only care about whether or not the dot product
                    is positive or negative. If it’s positive, then the triangle
                    is front facing, and we should draw it, if it’s negative, we
                    pass. And since mangnitude is always positive, we don’t
                    actually need to worry about it for this calculation.
                    <ul>
                      <li>
                        (later on, when we get to lighting, we will care about
                        mangnitude, but that’s a problem for future us, who will
                        be smarter than present us)
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Putting it all together</strong></p>
        <ul>
          <li>
            Given any triangle starting at P0:
            <ul>
              <li>
                Calculate \(\overrightarrow{N} = \overrightarrow{A} \times
                \overrightarrow{B}\), where \(\overrightarrow{A} = P_1 - P_0\),
                and \(\overrightarrow{B} = P_2 - P_0\).
              </li>
              <li>
                Calculate \(\overrightarrow{N} \cdot \overrightarrow{V}\), where
                \(\overrightarrow{V} = &lt;0, 0, 1&gt;\)
              </li>
              <li>
                If \(\overrightarrow{N} \cdot \overrightarrow{V} &gt; 0\), draw
                the triangle.
                <ul>
                  <li>
                    The keen observer will note that since \(\overrightarrow{V}
                    = &lt;0, 0, 1&gt;\), the x and y components of the dot
                    product will be 0. Also, since the z component of
                    \(\overrightarrow{V}\) is 1, the dot product will simply be
                    the z component of \(\overrightarrow{N}\).
                  </li>
                  <li>
                    This is ok for now, but eventually we will actually need the
                    value of the dot product, so it doesn’t hurt to do that now
                    anyway.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <h5 id="back-to-top-9"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="relative-coordinate-systems">Relative Coordinate Systems</h3>

        <p>
          Currently, all of our shapes are drawn in the same coordinate system.
          This was initially brought up back when we started transformations,
          noting that they were all done with respect to the origin. If our
          shapes were note centered at the origin, then scaling or rotating
          would move the shape in addition to performing the desired
          transformation.
        </p>

        <p>
          In a global coordinate system, it is also difficult to create complex
          objects made of multiple shapes. Take this “robot” for example:
        </p>

        <p><img src="../assets/img/n03-robot.png" alt="robot" /></p>

        <ul>
          <li>
            Some things to note about this image:
            <ul>
              <li>There are 8 distinct parts.</li>
              <li>Each part is positioned relative to the main “torso” box.</li>
              <li>The entire robot is rotated about the y-axis.</li>
              <li>Both arms are rotated about the x-axis.</li>
              <li>
                The left lower arm is rotated along with the upper arm, and then
                rotated independently of it.
              </li>
            </ul>
          </li>
        </ul>

        <p>
          In order to achieve this level of shape dependence and independence,
          we need to change the way we think about transformations. Currently:
        </p>
        <ul>
          <li>
            We create shapes without considering the world they will be drawn
            in, and separately build up transformations in a single
            transformation matrix.
          </li>
          <li>
            We manually apply the transformations to the points that make up our
            shapes.
          </li>
          <li>
            We only draw shapes to the screen when it is time to display/save.
          </li>
        </ul>

        <p>To implement relative coordinate systems:</p>
        <ul>
          <li>
            We modify the coordinate systems first with transformations, before
            generating shapes.
          </li>
          <li>
            When we add a shape, we generate the necessary polygons/lines and
            immediately place them in the current coordinate system (apply the
            current transformations).
          </li>
          <li>
            <em
              >We no longer draw a sphere and then rotate it, now we rotate the
              world and draw the sphere in the changed world.</em
            >
          </li>
          <li>
            This gives up shape independence, in order to create shape
            dependence, we need to keep track of changes we make to the world as
            we do them.
          </li>
        </ul>

        <p>
          We can achieve this by maintaining a <em>stack</em> of coordinate
          systems.
        </p>
        <ul>
          <li>
            Each coordinate system on the stack will represent the “world” at a
            specific time.
          </li>
          <li>
            When we push onto the stack, the new top will be based off of the
            previous top.
          </li>
          <li>
            Popping off the stack will act like rewinding to an earlier version
            of the coordinate system.
          </li>
          <li><strong>Main changes to our graphics engine</strong></li>
          <li>
            Replace the single master transformation matrix with a stack of
            matrices.
          </li>
          <li>
            Transformation commands modify the current top of the stack.
            <ul>
              <li>
                <strong>The order is important</strong>, is should be
                <strong>top * transformation</strong>
              </li>
            </ul>
          </li>
          <li>
            Adding shapes follows the following pipeline:
            <ol>
              <li>
                Generate the necessary polygons/lines (no changes needed in the
                drawing commands)
              </li>
              <li>
                Multiply the generated polygons/lines by the current top of the
                coordinate systems stack (placing the shape in the modified
                world).
              </li>
              <li>Draw the transformed polygons/lines to the screen.</li>
              <li>Clear out the polygons/lines.</li>
            </ol>
          </li>
        </ul>

        <h5 id="back-to-top-10"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="scanline-conversion">Scanline Conversion</h3>
        <p>
          Now that we have moved to a polygon based drawing engine (for 3D
          objects at least), we can realistically talk about filling in the
          polygons to make our shapes appear solid, instead of meshes.
        </p>

        <p>
          Filling in each polygon means that our engine needs to plot every
          single pixel on the surface of each object being drawn (this is were
          backface culling starts to pay off, since we are already ignoring any
          non-visible faces). Because this is so exhaustive, we’re going to need
          to make sure we’re doing our best to minimalize the amount of work our
          engine does to fill in the polygons. This is where scanline conversion
          comes in.
        </p>

        <p>
          Scanline conversion is the process of filling in a polygon by drawing
          a series of horizontal (or vertical) lines covering the entire surface
          of the polygon. This has a number of advantages over other possible
          approaches.
        </p>
        <ul>
          <li>
            The y value for each line is just 1 plus the previous y value.
          </li>
          <li>
            Horizontal lines have the same y value for each pixel, negating the
            need for y calculations inside the line algorithm.
          </li>
          <li>
            We can cover the entire surface while only visiting each pixel
            exactly <em>once</em>.
          </li>
        </ul>

        <p>
          In order to scanline convert a triangle, the first thing we have to do
          is find the top, bottom and middle vertices.
        </p>
        <ul>
          <li>
            As long as each triangle in our triangle matrix has 3 distinct
            vertices, there will always <em>at least</em> be a distinct top and
            bottom (this is why it was important not to add the degenerate
            triangles at the poles of a sphere). We can define the middle as the
            vertex that isn’t either the top or bottom (more on this later).
          </li>
          <li>
            <p>
              After ordering our vertices vertically, we have something like
              this:
            </p>

            <p>
              <img
                src="../assets/img/n04-scanline_convert.png"
                alt="scanline"
              />
            </p>
          </li>
        </ul>

        <p>
          Each scanline will go from one edge of the triangle to the other. In
          order to draw each line, we have to determine the endpoints.
        </p>
        <ul>
          <li>
            \(y\) values are very simple. They start at the bottom (\(y_b\)), go
            up by 1 each time, and end at the top (\(y_t\)).
          </li>
          <li>
            The \(x\) values are more complicated. They must move along the
            edges of the triangle. In the diagram above, I’ve designated that
            \(x_0\) for each scanline to be the endpoint somewhere along the
            line \(BT\), and \(x_1\) will be the other endpoint, which will
            either be along \(BT\) or \(MT\), depending on how far up we’ve made
            it.
            <ul>
              <li>
                It doesn’t matter if the middle vertex is to the left of right
                of the \(BT\) edge, since our
                <code class="language-plaintext highlighter-rouge"
                  >draw_line algorithm</code
                >
                will swap endpoints if they’re not listed left to right. This
                will make it easier to develop the scanline algorithm.
              </li>
            </ul>
          </li>
          <li>
            Calculating \(x_0\)
            <ul>
              <li>\(x_0\) starts at \(x_b\) and ends at \(x_t\)</li>
              <li>
                The question is, how much does \(x_0\) change with each scanline
                (\(\Delta x_0\))?
              </li>
              <li>The total change in \(x_0\) is \(x_t - x_b\).</li>
              <li>
                This change occurs over the course of drawing each scanline. So
                the number of scanlines determines the number of times we change
                \(x_0\). In turn, the number of scanlines is just the difference
                in \(y\) over the course of the triangle.
              </li>
              <li>\(\Delta x_0\) = (total change in x) / (# of scanlines)</li>
              <li>
                \(\Delta x_0 = (x_t - x_b) / (y_t - y_b + 1)\) (we need to add 1
                to the y difference to account for the bottom-most line)
              </li>
            </ul>
          </li>
          <li>
            Calculating \(x_1\)
            <ul>
              <li>
                \(x_1\) also starts at \(x_b\), but it ends at \(x_m\) and then
                changes direction to go to \(x_t\).
              </li>
              <li>
                We need to calculate \(\Delta x_1\) like with \(x_0\), but we
                will have 2 different values, depending on whether we’ve moved
                past the middle vertex or not.
              </li>
              <li>
                \(\Delta x_1 = (x_m - x_b) / (y_m - y_b + 1)\) <em>or</em>
              </li>
              <li>\(\Delta x_1 = (x_t - x_m) / (y_t - y_m + 1)\).</li>
              <li>
                We flip from the first to the second calculation once our \(y\)
                has reached \(y_m\).
              </li>
            </ul>
          </li>
        </ul>

        <p>
          Putting this all together, we can come up with this pseudocode
          outline:
        </p>

        <div class="language-plaintext highlighter-rouge">
          <div class="highlight">
            <pre class="highlight"><code>  //initial setup, find b, t, m
  x0 = xb, x1 = xb, y0 = yb
  dx0 = (xt - xb) / (yt - yb)
  dx1 = (xm - xb) / (ym - yb)
  dx1_1 = (xt - xm) / (yt - ym)
  while y &lt;= yt
      draw_line(x0, y, x1, y)
      //move the endpoints
      x0+= dx0
      x1+= dx1
      y+= 1
      //swap dx1 if neeced
      if y &gt;= ym
          dx1 = dx1_1
          x1 = xm
</code></pre>
          </div>
        </div>

        <ul>
          <li>
            It is a good idea to think of the loop here as having 3 distinct
            parts:
            <ul>
              <li>drawing the line</li>
              <li>updating the endpoints</li>
              <li>swapping \(\Delta x_1\)</li>
            </ul>
          </li>
          <li>
            The order in which you do these may not match the outline above,
            depending on how you handle “special” cases and other potential
            issues as they arise.
          </li>
        </ul>

        <p>“Special” Triangles</p>
        <ul>
          <li>
            Scanline conversion works very well when there are distinct top,
            bottom and middle vertices.
          </li>
          <li>
            Sometimes, there is no distinct middle (once again, there will
            always be a top and bottom).
          </li>
          <li>
            These are cases when two vertices have the same \(y\) value (either
            the top or bottom is a flat horizontal line).
          </li>
          <li>The \(x\) values will be different, which is important.</li>
          <li>
            You can handle these cases either explicitly or implicitly, but you
            do need to consider them.
          </li>
        </ul>

        <h5 id="back-to-top-11"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="z-buffering">Z-buffering</h3>
        <p>Z-buffering is another form of <em>hidden surface removal</em>.</p>
        <ul>
          <li>
            We are already doing backface culling, which removes all the
            polygons not facing the viewer.
          </li>
        </ul>

        <p>
          Z-buffering specifically deals with the case when there are 2 objects
          in an image and we have to determine which one is in front of the
          other, and thus is visible.
        </p>

        <p>
          Unlike backface culling, this needs to be done on a
          <strong>per pixel</strong> basis, instead of per polygon. Imagine a
          sphere in front of a box, just because the sphere is in front doesn’t
          mean we shouldn’t draw the entire front of the box, instead we just
          want to make sure that the sphere “covers” specific parts of the front
          of the box, and the other parts are still drawn.
        </p>

        <p>
          A Z-buffer is a 2D array of <strong>floating point</strong> z values
          that maps directly to the 2D array of colors/pixels that contains our
          image. For example, the Z-buffer value at \((4, 10)\) is the z
          coordinate for the pixel drawn at point \((4, 10)\).
        </p>

        <p>
          Currently when we plot a pixel we provide the \((x, y)\) coordinates
          and color.
        </p>
        <ul>
          <li>Now we will provide \((x, y, z)\) and a color.</li>
          <li>
            \((x, y)\) will determine the position in the image and z-buffer
          </li>
          <li>
            We will check the \(z\) value against the value currently in the
            z-buffer.
            <ul>
              <li>
                If the new \(z\) is larger (remember, +z is closer to the
                viewer), then we will update the image and z-buffer with the new
                values.
              </li>
              <li>
                Otherwise, we will skip plotting the pixel entirely, as there
                must already be an object at that position that is more in
                front.
              </li>
            </ul>
          </li>
          <li>
            In order for this to work, we need a good value to initialize
            z-buffer entries to.
            <ul>
              <li>
                What we want is a value that represents something so far away
                that any object we add would be on top.
              </li>
              <li>
                This should be the smallest (most negative) value representable
                in your language of choice.
                <ul>
                  <li>
                    For example, in c this is
                    <code class="language-plaintext highlighter-rouge"
                      >LONG_MIN</code
                    >
                    (defined in limits.h), in python it is
                    <code class="language-plaintext highlighter-rouge"
                      >float('-inf')</code
                    >.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <p>
          In addition to maintaining a z-buffer, we need to now calculate z
          values whenever we draw lines. This includes:
        </p>
        <ul>
          <li>
            <code class="language-plaintext highlighter-rouge">draw_line</code>
          </li>
          <li>
            <code class="language-plaintext highlighter-rouge"
              >scanline_convert</code
            >
          </li>
          <li>
            <code class="language-plaintext highlighter-rouge"
              >draw_scanline</code
            >
            <em>(if you made a separate function to just draw scanlines)</em>
          </li>
          <li>
            <code class="language-plaintext highlighter-rouge"
              >scanline_convert</code
            >
            <ul>
              <li>
                Here,
                <code class="language-plaintext highlighter-rouge">z</code>
                values can be treated the same as \(x\) values.
              </li>
              <li>\(z_0\) starts at \(z_b\) and goes to \(z_t\)</li>
              <li>
                \(z_1\) starts at \(z_b\), goes to \(z_m\) and then goes to
                \(z_t\)
              </li>
              <li>
                You need a \(\Delta z_0\) and \(\Delta z_1\). These are
                calculated the same was as their \(x\) equivalents:
                <ul>
                  <li>
                    \((total change in z) / (amount of scanlines)\) (see above
                    for specifics)
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <code class="language-plaintext highlighter-rouge">draw_line</code>
            and
            <code class="language-plaintext highlighter-rouge"
              >draw_scanline</code
            >
            <ul>
              <li>
                We actually have to go back to our very first graphics algorithm
                and modify it to take z values into account. On the plus side,
                we <em>need</em> z values to be floating point based, so we will
                not have to try to map them as best we can to integers. This
                makes the calculation more straightforward.
              </li>
              <li>
                You can think of generating
                <code class="language-plaintext highlighter-rouge">z</code>
                values in a similar way to what weed need to do in
                <code class="language-plaintext highlighter-rouge"
                  >scanline_convert</code
                >.
              </li>
              <li>
                If we are drawing a line from
                <code class="language-plaintext highlighter-rouge"
                  >(x0, y0, z0)</code
                >
                to
                <code class="language-plaintext highlighter-rouge"
                  >(x1, y1, z1)</code
                >, that means as we draw the line,
                <code class="language-plaintext highlighter-rouge">z</code> must
                go from
                <code class="language-plaintext highlighter-rouge">z0</code> to
                <code class="language-plaintext highlighter-rouge">z1</code>.
              </li>
              <li>
                Since we draw our lines 1 pixel at a time, we need to figure out
                how much
                <code class="language-plaintext highlighter-rouge">z</code>
                changes with each pixel. Like above:
                <ul>
                  <li>
                    \[\Delta z = (total change in z) / (amount of pixels)\]
                  </li>
                  <li>
                    Note that the denominator is the <em># of pixels</em> not
                    the length of the line.
                  </li>
                  <li>
                    If the line is in octants I or VIII, the total # of pixels
                    is based on the
                    <code class="language-plaintext highlighter-rouge">x</code>
                    values.
                  </li>
                  <li>
                    If the line is in octants II or VII, the total # of pixels
                    is based on the
                    <code class="language-plaintext highlighter-rouge">y</code>
                    values.
                  </li>
                  <li>
                    Just think about the value that controls the loop that
                    generates the line. Which coordinate is guaranteed to go up
                    by 1 each time?
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <h5 id="back-to-top-12"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="light-and-reflection-types">Light and Reflection Types</h3>
        <p>In the real world, the color of an object depends on:</p>
        <ul>
          <li>The color and location of any light source.</li>
          <li>The reflective properties of the object.</li>
          <li>
            Here are a few examples of how this works out:
            <ol>
              <li>
                If an object appears to be white then we know for certain:
                <ul>
                  <li>The object reflects white (that is all colors).</li>
                  <li>White light is hitting the object</li>
                </ul>
              </li>
              <li>
                If an object appears to be red, then we know for certain:
                <ul>
                  <li>The object reflects red light.</li>
                  <li>Red light is hitting the object.</li>
                </ul>
              </li>
              <li>
                If an object appears to be magenta (red and blue) then we know
                for certain:
                <ul>
                  <li>The object reflects red and blue light.</li>
                  <li>Red and blue light is hitting the object.</li>
                </ul>
              </li>
            </ol>
          </li>
          <li>
            Other things may be true in each of these scenarios. It’s possible
            that the light in 3 is white, and the object only reflects red and
            blue. It is equally possible that the object reflects all colors,
            but the light itself is only red and blue. Both of these scenarios
            would result in the same image.
          </li>
        </ul>

        <p>A lighting model must be able to take these things into account.</p>

        <h4 id="light-sources">Light Sources</h4>

        <p>
          We will work with 2 kinds of light sources, <em>ambient</em> and
          <em>point lights</em>.
        </p>

        <p>
          Both will have an associated color, either as an RGB triple or a
          single grayscale value.
        </p>

        <p><strong>Ambient Light</strong></p>
        <ul>
          <li>This is the general background lighting of an image.</li>
          <li>
            Imagine you were outside on a cloudy day, there would be a general
            amount of brightness to everything, but no one specific location
            that light was coming from.
          </li>
          <li>
            It is common to think about ambient light as if it is coming from
            all directions with equal intensity.
          </li>
          <li>This means that it doesn’t matter where an object is located.</li>
        </ul>

        <p><strong>Point Light Sources</strong></p>
        <ul>
          <li>Point light sources come from a specific location.</li>
          <li>Think of these like a flashlight or spot light.</li>
          <li>
            Here, the position of an object in important, since that will tell
            us the object’s relationship to the light source.
          </li>
          <li>
            It is possible for there to be multiple distinct point light sources
            in an image.
          </li>
        </ul>

        <h4 id="types-of-reflections">Types of Reflections</h4>

        <p>
          There are three kinds of reflections we will consider,
          <em>ambient</em>, <em>diffuse</em> and <em>specular</em>.
        </p>

        <p><strong>Ambient Reflection</strong></p>
        <ul>
          <li>
            This is simply the amount of ambient light reflected by an object.
          </li>
          <li>
            In the real world, this would not be separate from the other types
            of reflection, but it makes out modeling easier to separate it out.
          </li>
        </ul>

        <p><strong>Diffuse Reflection</strong></p>
        <ul>
          <li>This is specifically for reflection of a point light source.</li>
          <li>
            The reflection of a specific light source evenly in all directions.
            <ul>
              <li>
                Note this is different from ambient light in that ambient light
                comes from all directions. Here, it is only the reflection that
                goes in all directions.
              </li>
            </ul>
          </li>
          <li>
            Object that display a lot of diffuse reflection often appear dull or
            <em>matte</em>.
          </li>
          <li>
            Things like cloth or cardboard boxes tend to exhibit a lot of
            diffuse reflection.
          </li>
          <li>
            Diffuse reflection is dependent on the location of and object with
            respect to the point light source.
          </li>
        </ul>

        <p><strong>Specular Reflection</strong></p>
        <ul>
          <li>This is specifically for reflection of a point light source.</li>
          <li>
            The reflection of a specific light source in a specific direction.
            <ul>
              <li>
                Note the difference here between specular and diffuse
                reflection.
              </li>
            </ul>
          </li>
          <li>
            Objects that display a lot of specular reflection often appear
            shinny or <em>glossy</em>.
          </li>
          <li>
            Things like polished metal and glass tend to exhibit a lot of
            specular reflection.
          </li>
          <li>
            Since the reflection has a specific direction, specular reflection
            is dependent on the location of the object with respect to the point
            light source <strong>and</strong> the viewer. The more the viewer is
            in line with the reflected light, the strong the reflection will
            appear.
            <ul>
              <li>
                Note this is not needed in diffuse reflection because that is
                reflected evenly, so any viewing angle would result in the same
                image.
              </li>
            </ul>
          </li>
          <li>
            Specular reflections tend to be very strong and then die off
            quickly.
          </li>
        </ul>

        <h5 id="back-to-top-13"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="lighting-model">Lighting Model</h3>

        <p>
          We will be using the <em>Phong Reflection Model</em> to calculate the
          color of an object. (This is different from the Phong
          <em>shading</em> model, which is a separate concept).
        </p>

        <p>
          The Phong reflection model combines ambient, diffuse and specular
          reflections.
        </p>
        <ul>
          <li>
            <img
              src="../assets/img/n05-phong_reflection.png"
              alt="phong reflection"
            />
          </li>
        </ul>

        <p>The color of an object will depend on:</p>
        <ul>
          <li>
            <strong>A</strong>: The color of ambient light (RGB or a single
            value [0-255])
            <ul>
              <li>e.g. 255, 255, 255 (white)</li>
            </ul>
          </li>
          <li>
            <strong>P</strong>: The color of a point light source (RGB or a
            single value [0-255])
            <ul>
              <li>e.g. 255, 0, 255 (magenta)</li>
            </ul>
          </li>
          <li>
            \(\overrightarrow{L}\): The vector from the surface of an object to
            a point light source ( \(&lt;x, y, z&gt;\) ).
            <ul>
              <li>
                e.g. \(&lt;1, 0.5, 1&gt;\) (to the right, slightly up and in
                front)
              </li>
            </ul>
          </li>
          <li>
            \(\overrightarrow{V}\): The view vector (from the surface of an
            object to the viewer) ( \(&lt;x, y, z&gt;\) ).
            <ul>
              <li>e.g. \(&lt;0, 0, 1&gt;\) (directly in front)</li>
            </ul>
          </li>
          <li>
            \(\overrightarrow{N}\): The surface normal of a polygon, see notes
            on <a href="#backface-culling">backface culling</a> for more on
            this.
          </li>
          <li>
            <strong>Ka</strong>: Constant of ambient reflection; how much
            ambient light is reflected by the object. ( RGB or a single value
            [0-1], think of it like a %).
            <ul>
              <li>e.g. 0.1, 0.1, 0.1</li>
            </ul>
          </li>
          <li>
            <strong>Kd</strong>: Constant of diffuse reflection; how much a
            point light is reflected diffusely by the object. ( RGB or a single
            value [0-1] ).
            <ul>
              <li>e.g. 0.5, 0.5, 0.5</li>
            </ul>
          </li>
          <li>
            <strong>Ks</strong>: Constant of specular reflection; how much a
            point light is reflected specularly by the object. ( RGB or a single
            value [0-1] ).
            <ul>
              <li>e.g. 0.5, 0.5, 0.5</li>
            </ul>
          </li>
        </ul>

        <p>
          In general, <strong>I</strong> (for illumination), or the color of an
          object based on lighting will be calculated by:
        </p>
        <ul>
          <li>\[I = I_{ambient} + I_{diffuse} + I_{specular}\]</li>
        </ul>

        <p>Ambient Reflection</p>
        <ul>
          <li>
            This is the ambient component of color. It is the easiest to compute
            since we don’t need to take into account the location of the object
            or the viewer.
          </li>
          <li>
            equation: \(I_{ambient} = AK_a\)
            <ul>
              <li>
                If working in RGB instead of grayscale, you’ll have to compute
                this separately for each color.
              </li>
            </ul>
          </li>
        </ul>

        <p>Diffuse Reflection</p>
        <ul>
          <li>
            This is the diffuse reflection of a point light source. We will need
            to model the relationship between the light source and the object.
            <ul>
              <li>
                <img
                  src="../assets/img/n06-diffuse_reflection.jpg"
                  alt="diffuse reflection"
                />
              </li>
            </ul>
          </li>
          <li>
            Diffuse reflection is strongest when the surface is pointing
            directly at the light, and gets weaker as the object points away
            from the light.
          </li>
          <li>
            Put another way, the diffuse reflection is inversely proportional to
            \(\theta\).
          </li>
          <li>This can be modeled with \(cos\theta\).</li>
          <li>
            Lucky, for us, we already know that \(cos\theta\) is the dot product
            of the two vectors. Unlike with backface culling, we
            <em>DO</em> care about the magnitudes, so it is in our best interest
            to normalize both\(\overrightarrow{N}\) and \(\overrightarrow{L}\)
            <ul>
              <li>
                The normalized version of a vector is often shown with a ^ like
                so: \(\hat{N}\).
              </li>
              <li>
                To normalize a vector, divide each component by the magnitude of
                the original vector.
              </li>
              <li>
                For Vector \(\overrightarrow{A} = &lt;x, y, z&gt;\), \(M =
                \sqrt{x^2 + y^2 + z^2}\), \(\hat{A} = &lt;\dfrac{x}{M},
                \dfrac{y}{M}, \dfrac{z}{M}&gt;\)
              </li>
            </ul>
          </li>
          <li>
            Once normalized, we can do: \(cos\theta = \hat{N} \cdot \hat{L}\)
          </li>
          <li>
            Combined with P and Kd, we get:
            <ul>
              <li>\[I_{diffuse} = PK_d(\hat{N} \cdot \hat{L})\]</li>
            </ul>
          </li>
        </ul>

        <p>Specular Reflection</p>
        <ul>
          <li>
            This is the specular reflection of a point light source. We will
            need to model the relationship between the light source and the
            <em>viewer</em>.
            <ul>
              <li>
                <img
                  src="../assets/img/n07-specular_reflection.jpg"
                  alt="specular reflection"
                />
              </li>
            </ul>
          </li>
          <li>
            Specular reflection is strongest when the reflected light is
            pointing directly at the viewer.
          </li>
          <li>
            This is inversely proportional to \(\alpha\), and can be modeled by
            \(cos\alpha\).
          </li>
          <li>Here we need: \(cos\alpha = \hat{R} \cdot \hat{V}\)</li>
          <li>
            \(\hat{V}\) is given, but how can we find \(\hat{R}\)?
            <ul>
              <li><img src="../assets/img/n08-r.jpg" alt="reflection" /></li>
              <li>
                Usint the above diagram: \(\hat{R} = \overrightarrow{T} +
                \overrightarrow{S}\)
              </li>
              <li>
                \(\overrightarrow{T}\) is the projection of \(\hat{L}\) onto
                \(\hat{N}\)
                <ul>
                  <li>
                    The result is a vector with the same direction as
                    \(\hat{N}\), but with a magnitude scaled by \(\hat{L}\).
                  </li>
                  <li>
                    \[\overrightarrow{T} = \hat{N}(\hat{N} \cdot \hat{L})\]
                  </li>
                  <li>
                    Note that while \(\hat{N}\) and \(\hat{L}\) should be
                    normalized, \(\overrightarrow{T}\) will not be (unless
                    \(\alpha = 0\))
                  </li>
                  <li>
                    Now we know \(\overrightarrow{T}\) in terms of information
                    we already have.
                  </li>
                </ul>
              </li>
              <li>
                \(\overrightarrow{S}\) can be found by doing some similar
                triangle work.
                <ul>
                  <li>\[\hat{L} + \overrightarrow{S} = \overrightarrow{T}\]</li>
                  <li>\[\overrightarrow{S} = \overrightarrow{T} - \hat{L}\]</li>
                  <li>
                    \[\overrightarrow{S} = \hat{N}(\hat{N} \cdot \hat{L}) -
                    \hat{L}\]
                  </li>
                </ul>
              </li>
              <li>
                Which then gives us:
                <ul>
                  <li>
                    \[\hat{R} = \hat{N}(\hat{N} \cdot \hat{L}) + \hat{N}(\hat{N}
                    \cdot \hat{L}) - \hat{L}\]
                  </li>
                  <li>
                    \[\hat{R} = 2\hat{N}(\hat{N} \cdot \hat{L}) - \hat{L}\]
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Usin this, we get \(\cos\alpha =[2\hat{N}(\hat{N} \cdot \hat{L}) -
            \hat{L}] \cdot \hat{V}\)
          </li>
          <li>
            Combined with P and Ks we get:
            <ul>
              <li>
                \[I_{specular} = PK_s([2\hat{N}(\hat{N} \cdot \hat{L}) -
                \hat{L}] \cdot \hat{V})\]
              </li>
              <li>
                This doesn’t take into account the fact that specular
                reflections are supposed to die off quickly. Note that the
                specular component from the Phone reflection image above is
                mostly a group of small, bright circles. The simplest way to get
                this effect is to raise \(cos\alpha\) to some exponenet larger
                than 1. The specific value will depend on what looks right to
                you.
              </li>
              <li>
                \[I_{specular} = PK_s([2\hat{N}(\hat{N} \cdot \hat{L}) -
                \hat{L}] \cdot \hat{V})^x\]
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Putting it all together</strong></p>
        <ul>
          <li>\[I = I_{ambient} + I_{diffuse} + I_{specular}\]</li>
          <li>
            \[I = AK_a + PK_d(\hat{N} \cdot \hat{L}) + PK_s([2\hat{N}(\hat{N}
            \cdot \hat{L}) - \hat{L}] \cdot \hat{V})^x\]
          </li>
          <li>
            For now, we should calculate \(I\) once per polygon. This is known
            as <strong>flat shading</strong>. Later on we will look at other
            shading options.
          </li>
        </ul>

        <h5 id="back-to-top-14"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="compiler-design">Compiler Design</h3>

        <p>
          Our current parser is simplistic. It was great for what we were doing,
          but we need more flexibility in our image description files. Things
          that would be nice to have:
        </p>
        <ul>
          <li>A way to define ambient light.</li>
          <li>A way to define point light sources.</li>
          <li>
            A way to create a set of reflection constants such that we can reuse
            them when we add objects without having to type out 9 values each
            time.
          </li>
          <li>
            A way to define a coordinate system totally independent of the
            current stack and use that when placing some objects (to give more
            control over our images).
          </li>
          <li>A looping structure to help with animation.</li>
        </ul>

        <p>
          The last 3 things on the list above are really the sorts of things you
          would see in a programming language. The last one being a loop and the
          other 2 being essentially variables. So we are going to move from a
          simple parser to a more robust compiler-style design. In order to do
          so, we have to know more about how compilers work.
        </p>

        <p><strong>The Compiler Pathway</strong></p>

        <p>
          Until now, you’ve probably thought about a compiler in the following
          way:
        </p>
        <ol>
          <li>Source code</li>
          <li>
            ?
            <a
              href="../assets/img/underpants_gnomes.png"
              style="color: lightsteelblue"
            >
              this sounds familiar…</a
            >
          </li>
          <li>Executable code</li>
        </ol>

        <p>
          Turns out, a lot happens in step 2. Compilers are made of the
          following parts:
        </p>
        <ul>
          <li>Lexer</li>
          <li>Parser</li>
          <li>Semantic Analyzer</li>
          <li>Optimizer</li>
          <li>Code Generator</li>
        </ul>

        <p>
          As your code goes through these parts, it gets transformed into
          various structures that are less human-friendly but more
          computer-friendly, until we end up with a binary executable program.
        </p>

        <p><strong>Lexer</strong></p>
        <ul>
          <li>
            A lexer performs <em>lexical analysis</em>, which means that its job
            is to identify the tokens in a programming file. (A
            <em>lexicon</em> is the total collection of words in a language).
          </li>
          <li>
            The lexer will take in a computer program and output a list of
            program tokens. Takes this example c code:
            <div class="language-plaintext highlighter-rouge">
              <div class="highlight">
                <pre class="highlight"><code>int main() {
    int x;
    x = 5 * 18;
    printf("%d", x);
    return 0;
}
</code></pre>
              </div>
            </div>
          </li>
          <li>
            After going through a lexer, the code would look something like
            this:
            <div class="language-plaintext highlighter-rouge">
              <div class="highlight">
                <pre class="highlight"><code>INT
IDENTIFIER main
(
)
{
int
IDENTIFIER x
;
x
ASSIGNMENT
VALUE 5
MULTIPLY
VALUE 18
...
</code></pre>
              </div>
            </div>
          </li>
          <li>
            As you can see, a lot of the things programmers use to make their
            code readable, like whitespace and comments, immediately get
            stripped out.
          </li>
          <li>
            The only errors that a lexer will catch will be invalid tokens (like
            bad variable names, invalid symbols…). The lexer doesn’t know
            anything about the structure of the programming language.
          </li>
          <li>
            Natural language example:
            <em>greedily cat computer overstates</em> contains valid English
            tokens, and would thus pass the lexer stage.
          </li>
          <li>
            In order for a lexer to work, it must be programmed with all
            possible tokens in the programming language. For things like
            keywords and symbols, you can list them out. But for more
            interesting structures, like strings, identifiers and number values,
            you have to use
            <a
              href="https://regexcrossword.com/challenges/tutorial/puzzles/1"
              target="_blank"
              >regular expressions</a
            >
          </li>
        </ul>

        <p><strong>Parser</strong></p>
        <ul>
          <li>The parser performs <em>syntactic analysis</em>.</li>
          <li>
            This means that the parser checks the <em>token list</em> against
            the grammatical rules of the language.
          </li>
          <li>
            The parser will output a <em>syntax tree</em> and a corresponding
            <em>token list</em>.
          </li>
          <li>
            The syntax tree for the code above might look something like this:
            <ul>
              <li>
                <img
                  src="../assets/img/n09-syntax_tree.png"
                  alt="syntax tree"
                />
              </li>
            </ul>
          </li>
          <li>
            Notice that the grouping symbols (i.e.
            <code class="language-plaintext highlighter-rouge">() {} ;</code>)
            have been stripped away and are now built into the syntax tree.
          </li>
          <li>
            The <em>symbol table</em> is going to be a list of symbols, mostly
            the identifiers, found in the syntax tree.
            <ul>
              <li>
                Syntax tree nodes will link to the symbol table when
                appropriate.
              </li>
            </ul>
          </li>
          <li>
            The parser will only be able to find structural errors.
            <ul>
              <li>
                Natural language example:
                <em>cat the hungry ate mouse</em> would not pass the parser
                stage, while <em>the tree computed blue integrals</em> would,
                despite not making any sense.
              </li>
            </ul>
          </li>
          <li>
            In order for a parser to work, it must be programmed with the syntax
            of the language. This is commonly done using a
            <strong>context free grammar</strong>.
          </li>
        </ul>

        <p><strong>Semantic Analyzer</strong></p>
        <ul>
          <li>
            The semantic analyzer takes the syntax tree and create a list of
            operations in the order that they need to be performed in order for
            the program to work.
          </li>
          <li>
            The semantic analyzer might make an operations list like the
            following:
            <div class="language-plaintext highlighter-rouge">
              <div class="highlight">
                <pre class="highlight"><code>MULTIPLY 5, 8
ASSIGN x PREVIOUS
printf "%d", x
</code></pre>
              </div>
            </div>
            <ul>
              <li>
                The
                <code class="language-plaintext highlighter-rouge">ASSIGN</code>
                line would have some reference to the previous line.
              </li>
              <li>
                Things like
                <code class="language-plaintext highlighter-rouge">x</code> and
                <code class="language-plaintext highlighter-rouge">printf</code>
                would refer to the symbol table.
              </li>
            </ul>
          </li>
          <li>
            The operations list can be designed such that it can then be
            directly translated into processor operations, ready to be
            translated into binary code.
          </li>
        </ul>

        <p><strong>Optimizer</strong></p>
        <ul>
          <li>
            Once we have a list operations to be performed, the optimizer can
            look it over and potential provide size &amp; time improvements.
          </li>
          <li>
            Some possible examples are removing unused variables from the symbol
            table, removing conditional statements that are always true/false…
          </li>
          <li>
            Depending on the compiler and optimization level, the post-optimized
            operation list could result in code that is different enough from
            the source that debugging could be difficult.
          </li>
          <li>
            <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"
              >Here</a
            >
            is a list of possible optimizations for
            <code class="language-plaintext highlighter-rouge">gcc</code>.
          </li>
        </ul>

        <p><strong>Code Generator</strong></p>
        <ul>
          <li>
            This is the part of the compiler that generates the executable code.
          </li>
          <li>
            At this point, the operations list can be traversed and translated
            into executable binary code.
          </li>
          <li>
            Some compilers will provide an option to create an
            <em>assembly code</em> file instead of an executable binary. You can
            do this in
            <code class="language-plaintext highlighter-rouge">gcc</code> with
            the
            <code class="language-plaintext highlighter-rouge">-S</code> flag.
          </li>
        </ul>

        <h5 id="back-to-top-15"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="using-flex-and-bison-to-create-mdl">
          Using Flex and Bison to Create MDL
        </h3>

        <p>
          Building a compiler from scratch is difficult, and many of the
          processes are the same for any language, the only differences being in
          the list of possible tokens and the grammar. There are a number of
          tools out there to help with compiler design, provided that you can
          define the tokens (using <em>regular expressions</em>) and the
          structure (using a <em>context free grammar</em>). In C, there are
          well known tools:
        </p>
        <ul>
          <li>
            lex: Generates a lexer based on a token list (usually defined in a
            <code class="language-plaintext highlighter-rouge">.l</code> file).
          </li>
          <li>
            yacc (Yet Another C Compiler): Generate a parser &amp; semantic
            analyzer based on a context free grammar (usually defined in a
            <code class="language-plaintext highlighter-rouge">.y.</code> file).
          </li>
          <li>
            Both of these utilities are not open-source, and are part of a
            standard Unix system. So we will be using the follow open source
            (and newer) replacements:
            <ul>
              <li>lex -&gt; <em>flex</em> (faster lex)</li>
              <li>
                yacc -&gt; <em>bison</em> (kind of like a
                <a
                  href="https://en.wikipedia.org/wiki/Domestic_yak"
                  target="_blank"
                  >yak</a
                >)
              </li>
            </ul>
          </li>
        </ul>

        <p>
          For python, we will be using a fairly direct port of lex &amp; yacc
          (provided in the source code. direct link
          <a href="https://www.dabeaz.com/ply/" target="_blank">here</a>)
        </p>

        <p>
          For you java fans, you will have to investigate javacc (<a
            href="https://javacc.github.io/javacc/"
            target="_blank"
            >java compiler compiler</a
          >)
        </p>

        <p><strong>MDL</strong></p>
        <ul>
          <li>
            MDL is the language we will create for our graphics programs (stands
            for Motion Description Language).
          </li>
          <li>All of our image script files will now use MDL syntax.</li>
          <li>
            For us, our MDL source code will go through our custom compiler and
            output an image (instead of an executable binary).
            <ul>
              <li>
                Later on, when we get to animation, we will output many files.
              </li>
            </ul>
          </li>
          <li>
            The lexicon &amp; grammar for MDL for all the base MDL commands is
            provided for you (you may wish to add commands for a final project).
          </li>
          <li>
            Your job will be to parse the operation list output by the semantic
            analyzer (created using bison), to perform the graphics operations
            and output an image file.
          </li>
          <li>
            This is analogous to the <em>code generator</em> of a compiler.
          </li>
        </ul>

        <h5 id="back-to-top-16"><a href="#">Back to top</a></h5>
        <hr />

        <h3 id="animation">Animation</h3>
        <p>
          An animated imaage is simply a whole lot of similar images strung
          together. We will procedurally generate animated images by taking a
          transformation and applying it over a series of individual frames.
        </p>
        <ul>
          <li>
            For example, if we want a ball to roll across the screen, we could
            frame that as a
            <code class="language-plaintext highlighter-rouge">move</code>
            command that is applied increasingly. We can think about this as if
            we’re adding an extra argument to move, representing the amount of
            the transformation to apply.
            <ul>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >move 400 0 0 0</code
                >
              </li>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >move 400 0 0 0.25</code
                >
              </li>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >move 400 0 0 0.5</code
                >
              </li>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >move 400 0 0 0.75</code
                >
              </li>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >move 400 0 0 1</code
                >
              </li>
            </ul>
          </li>
          <li>
            Here we have the move command applied first at 0%, then in 25%
            increments until we get to 100%. The entire animation would take
            place over 5 frames.
          </li>
        </ul>

        <p>
          In MDL, we will create this effect using a new type of variable called
          a <em>knob</em>.
        </p>
        <ul>
          <li>
            A <em>knob</em> is an optional parameter to any transformation
            command.
          </li>
          <li>
            If a knob name is present at the end of the transformation, it means
            that transformation is designed to be applied incrementally over
            some number of frames.
          </li>
          <li>
            We define the behavior of the knob in a new MDL command:
            <code class="language-plaintext highlighter-rouge">vary</code>
            <ul>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >vary knob start_frame end_frame start_value end_value</code
                >
                <ul>
                  <li>
                    This command defines the knob behavior. To get the move
                    command to work the way it’s described above, we would use
                    the following code:
                    <ul>
                      <li>
                        <code class="language-plaintext highlighter-rouge"
                          >move 400 0 0 knobby</code
                        >
                      </li>
                      <li>
                        <code class="language-plaintext highlighter-rouge"
                          >vary knobby 0 5 0 1</code
                        >
                      </li>
                    </ul>
                  </li>
                  <li>
                    Some important things to keep in mind about
                    <code class="language-plaintext highlighter-rouge"
                      >vary</code
                    >
                  </li>
                  <li>
                    You could have multiple vary commands for the same knob, as
                    long as they don’t overlap in frames.
                  </li>
                  <li>
                    <code class="language-plaintext highlighter-rouge"
                      >start_frame</code
                    >
                    should always be less than
                    <code class="language-plaintext highlighter-rouge"
                      >end_frame</code
                    >.
                  </li>
                  <li>
                    <code class="language-plaintext highlighter-rouge"
                      >end_frame</code
                    >
                    should always be less than or equal to the total number of
                    frames.
                  </li>
                  <li>The value can increase or decrease over time.</li>
                  <li>
                    The value range can be bounded by any floating point values.
                  </li>
                  <li>The frame and value ranges are inclusive.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Implementing Animation in MDL</strong></p>
        <ul>
          <li>
            In addition to knobs and the
            <code class="language-plaintext highlighter-rouge">vary</code>
            command, we’ll have 2 other new commands:
            <ul>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >frames x</code
                >: Set the total number of frames for the animation.
              </li>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >basename s</code
                >: Set the base file name for each frame file.
              </li>
            </ul>
          </li>
          <li>
            In order to produce an animation, we will go through the operations
            list three times:
          </li>
          <li>
            Pass 0:
            <ul>
              <li>
                Look for the animation related commands:
                <code class="language-plaintext highlighter-rouge">frames</code>
                <code class="language-plaintext highlighter-rouge"
                  >basename</code
                >
                <code class="language-plaintext highlighter-rouge">vary</code>.
              </li>
              <li>
                Set
                <code class="language-plaintext highlighter-rouge">frames</code>
                and
                <code class="language-plaintext highlighter-rouge"
                  >basename</code
                >
                somewhere in your code, if they are present.
              </li>
              <li>
                If
                <code class="language-plaintext highlighter-rouge">vary</code>
                is present, but
                <code class="language-plaintext highlighter-rouge">frames</code>
                is not, this should be considered an MDL compiler error, handle
                it accordingly.
              </li>
              <li>
                If
                <code class="language-plaintext highlighter-rouge">frames</code>
                is preset, but
                <code class="language-plaintext highlighter-rouge"
                  >basename</code
                >
                is not, print a warning, and set the basename to some default
                value.
              </li>
            </ul>
          </li>
          <li>
            Pass 1:
            <ul>
              <li>
                This is the bulk of the new work for animation. In this pass, we
                will compute all the knob values for every frame and store them
                in a data structure to be used when we actually draw each frame.
              </li>
              <li>
                Create an array/list, where each index represents a frame.
                <ul>
                  <li>
                    Each index will contain a list of the knobs and their values
                    for that frame.
                  </li>
                </ul>
              </li>
              <li>
                When you see the
                <code class="language-plaintext highlighter-rouge">vary</code>
                command, compute how it changes, and add entries in the knob
                table for each frame covered in the
                <code class="language-plaintext highlighter-rouge">vary</code>
                command.
                <ul>
                  <li>
                    Use a simple linear interpolation for the change (i.e.
                    total_change/frames ).
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Pass 2:
            <ul>
              <li>
                This is the normal drawing loop with 3
                <em>potential</em> changes (depending on if the frames is
                greater than 1).
              </li>
              <li>
                Ignore
                <code class="language-plaintext highlighter-rouge">frames</code
                >,
                <code class="language-plaintext highlighter-rouge"
                  >basename</code
                >
                and
                <code class="language-plaintext highlighter-rouge">vary</code>
                commands, as they would have been taken care of in passes 0 and
                1.
              </li>
              <li>If frames is 1, do nothing differently from before.</li>
              <li>
                If there are more than 1 frame:
                <ul>
                  <li>
                    Before evaluating any commands, go through the knob values
                    computed from pass 1. Update the symbol table accordingly.
                  </li>
                  <li>
                    Go through all the commands, when a knob is present, use the
                    value stored in the symbol table.
                  </li>
                  <li>
                    Ignore the
                    <code class="language-plaintext highlighter-rouge"
                      >display</code
                    >
                    and
                    <code class="language-plaintext highlighter-rouge"
                      >save</code
                    >
                    commands, no one wants to have these things run all the
                    time.
                  </li>
                  <li>
                    After drawing <em>each</em> frame, save it. Use the basename
                    followed by a number (leading 0s are very useful, see the
                    assignment for tips on adding them).
                  </li>
                  <li>
                    After drawing all the frames, stitch them together into an
                    animated gif, more on that below.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Dealing with frames and animated gifs</strong></p>
        <ul>
          <li>
            You will be generating <em>a lot</em> of images. You should create a
            directory to store all the frames so they don’t overrun your code
            directory.
            <ul>
              <li>
                Pro tip: Git does not track empty directories, so put some
                placeholder text file in your frame directory so that it shows
                up on GitHub (remember <strong>DO NOT</strong> upload all your
                image files).
              </li>
            </ul>
          </li>
          <li>
            There are 2 relevant imagemagick commands for us.
            <ul>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >$ animate</code
                >
                <ul>
                  <li>
                    Will display an animation based on the files given as
                    parameters.
                  </li>
                  <li>
                    You can individual list files like this:
                    <code class="language-plaintext highlighter-rouge"
                      >$ animate frame0.png frame1.png frame2.png</code
                    >
                    or, the better option, use the
                    <code class="language-plaintext highlighter-rouge">*</code>
                    character. This will only work if your files all have the
                    same start to their names. It will stitch them together in
                    the same order that they appear when running
                    <code class="language-plaintext highlighter-rouge"
                      >$ ls</code
                    >, which is why I suggest using at least 1 leading 0 when
                    naming the frames.
                  </li>
                  <li>
                    This command should also be used when displaying an animated
                    gif. Using the
                    <code class="language-plaintext highlighter-rouge"
                      >display</code
                    >
                    command is not advised.
                  </li>
                </ul>
              </li>
              <li>
                <code class="language-plaintext highlighter-rouge"
                  >$ convert</code
                >
                <ul>
                  <li>
                    We already use convert to change image file types, but it
                    can also be used to make animated gifs.
                  </li>
                  <li>
                    If you give convert multiple files and specify the output
                    format as a gif, it will automatically create an animated
                    gif.
                  </li>
                  <li>
                    It works similar to
                    <code class="language-plaintext highlighter-rouge"
                      >animate</code
                    >
                    in terms of the ordering of files.
                  </li>
                  <li>
                    There is an extra argument which you may want to use called
                    <code class="language-plaintext highlighter-rouge"
                      >-delay</code
                    >
                    it helps specify the framerate.
                    <ul>
                      <li>
                        Normally, we think of framerate in Frames Per Second
                        (fps).
                      </li>
                      <li>
                        So 24 fps would mean 24 frames every second, this is the
                        standard for film-based movies. 30 fps is the standard
                        for TV shows (at least in the US, 25 for the rest of the
                        world). 60 fps is a common HD framerate.
                      </li>
                      <li>
                        gifs measure frames a little differently, counting
                        delays between frames in 1/100 second units. So we tend
                        to think of gifs not in fps but in delay between frames,
                        which is actually seconds per frame. To turn that into
                        fps, just invert the value.
                      </li>
                      <li>
                        <code class="language-plaintext highlighter-rouge"
                          >-delay t</code
                        >
                        will put a
                        <code class="language-plaintext highlighter-rouge"
                          >t</code
                        >/100 second delay between each frame. So if
                        <code class="language-plaintext highlighter-rouge"
                          >t</code
                        >
                        = 20, there will be 1/5 second delay between frames
                        <em>or</em> 5 fps. A delay of 1.7 is close to 60fps, 4.1
                        is close to 24fps, 3.3 is close to 30fps.
                      </li>
                    </ul>
                  </li>
                  <li>
                    An example of using
                    <code class="language-plaintext highlighter-rouge"
                      >convert</code
                    >
                    on a bunch of images that begin with the name
                    <code class="language-plaintext highlighter-rouge"
                      >rolling</code
                    >:
                    <ul>
                      <li>
                        <code class="language-plaintext highlighter-rouge"
                          >$ convert rolling* -delay 1.7 rolling.gif</code
                        >
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <h5 id="back-to-top-17"><a href="#">Back to top</a></h5>
      </div>
    </div>
  </body>
</html>
